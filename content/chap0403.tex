\section{包围盒层次}\label{sec:包围盒层次}

\keyindex{包围盒层次}{bounding volume hierarchy}{}(BVH)是一种
基于图元细分的光线相交加速方法，把图元划分为不相交集合的层次
（相反，空间细分一般把空间划分为不相交集合的层次）。
\reffig{4.2}展示了简单场景的包围盒层次\sidenote{译者注：包围盒是边界框的近义词。}。
图元存于\keyindex{叶子}{leaf}{}中，只要它不与节点的边界相交，
该节点下的子树就可以跳过。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Primitivesandhierarchy.tex}
    \caption{简单场景的包围盒层次。(a)一小部分图元，边界框用虚线表示。
        图元基于邻近度聚合；这里，球体和等边三角形在被框住整个场景的边界框
        围住之前都被另一个边界框包围了（都用实线表示）。(b)相应的包围盒层次。
        根节点持有整个场景。这里它有两个孩子，一个保存包围了球体和等边三角形的边界框
        （又把这些图元作为其孩子），另一个保存持有瘦三角形的边界框。}
    \label{fig:4.2}
\end{figure}

图元细分的一个性质是每个图元只在层次中出现一次。
相反，一个图元可能与空间细分的多个空间区域重合，
因此在光线穿过它们时要多次测试相交
\footnote{\protect\keyindex{邮箱}{mailboxing}{}技术可用于
    让使用空间细分的加速器避免这样的多次相交，但它的实现在存在多进程时会很棘手。
    “扩展阅读”一节有关于邮箱的更多信息。}。
该性质还意味着表示图元细分层次所需的内存量是有界的。
对于每个叶子中保存单个图元的二叉BVH，节点总数为$2n-1$，其中$n$是图元数量。
有$n$个叶子节点和$n-1$个内部节点
\sidenote{译者注：这些结论利用了二叉BVH的前提：每个节点要么是叶子节点，要么是有两个孩子的内部节点。}。
如果叶子保存了多个图元，则需要的节点更少。

构建BVH比kd树更高效，kd树分发光线相交测试通常比BVH稍快但构建时间长得多。
另一方面，BVH通常数值更稳定，比起kd树更不容易因为舍入误差错过相交。

BVH加速器{\refvar{BVHAccel}{}}定义在\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.h}{\ttfamily accelerators/bvh.h}
和\href{https://github.com/mmp/pbrt-v3/tree/master/src/accelerators/bvh.cpp}{\ttfamily accelerators/bvh.cpp}
中。除了要保存的图元以及任何叶子节点中的最大图元数目，
其构造函数还接收一个描述当划分图元以构建树时要用四个算法中哪一个的枚举值。
应该用默认值\refvar{SAH}{}，它表示\refsub{表面积启发法}讨论的基于“表面积启发法”的算法。
另一个是\refsub{线性包围盒层次}讨论的\refvar{HLBVH}{}，
它能更高效地构造（且更易并行化），但建立的树不如\refvar{SAH}{}高效。
剩下的两种方法使用的计算量甚至更少，但创建的树的质量非常低。
\begin{lstlisting}
`\initcode{BVHAccel Public Types}{=}`
enum class `\initvar{SplitMethod}{}` { `\initvar{SAH}{}`, `\initvar{HLBVH}{}`, `\initvar{Middle}{}`, `\initvar{EqualCounts}{}` };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Method Definitions}{=}\initnext{BVHAccelMethodDefinitions}`
`\initvar{BVHAccel}{}`::`\refvar{BVHAccel}{}`(const std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &p,
         int maxPrimsInNode, `\refvar{SplitMethod}{}` splitMethod)
     : `\refvar{maxPrimsInNode}{}`(std::min(255, maxPrimsInNode)), `\refvar[BVHAccel::primitives]{primitives}{}`(p),
       `\refvar{splitMethod}{}`(splitMethod) {
    if (primitives.size() == 0)
        return;
    `\refcode{Build BVH from primitives}{}`
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Private Data}{=}\initnext{BVHAccelPrivateData}`
const int `\initvar{maxPrimsInNode}{}`;
const `\refvar{SplitMethod}{}` `\initvar{splitMethod}{}`;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> `\initvar[BVHAccel::primitives]{primitives}{}`;
\end{lstlisting}

\subsection{BVH构建}\label{sub:BVH构建}
这里的实现中构建BVH有三个阶段。
首先，计算关于每个图元的边界信息并保存到将于树构建期间使用的数组中。
接着，用选择的编码于\refvar{SplitMethod}{}的算法构建树。
结果是\keyindex{二叉树}{binary tree}{}每个内部节点
都有指针指向其孩子且每个叶子节点都有指向一个或多个图元的引用。
最后，该树转化为更紧实（且因此更高效）的无指针表示以供渲染时使用
（虽然在构建树期间直接计算无指针表示也可以，但用该方法实现更简单）。
\begin{lstlisting}
`\initcode{Build BVH from primitives}{=}`
`\refcode{Initialize primitiveInfo array for primitives}{}`
`\refcode{Build BVH tree for primitives using primitiveInfo}{}`
`\refcode{Compute representation of depth-first traversal of BVH tree}{}`
\end{lstlisting}

对于每个要存于BVH的图元，我们在结构体\refvar{BVHPrimitiveInfo}{}的一个实例中
存储其边界框的形心、完整边界框以及它在\refvar{primitives}{}数组中的索引。
\begin{lstlisting}
`\initcode{Initialize primitiveInfo array for primitives}{=}`
std::vector<`\refvar{BVHPrimitiveInfo}{}`> primitiveInfo(`\refvar[BVHAccel::primitives]{primitives}{}`.size());
for (size_t i = 0; i < `\refvar[BVHAccel::primitives]{primitives}{}`.size(); ++i)
    primitiveInfo[i] = { i, `\refvar[BVHAccel::primitives]{primitives}{}`[i]->`\refvar[Primitive::WorldBound]{WorldBound}{}`() };
\end{lstlisting}
\begin{lstlisting}
`\initcode{BVHAccel Local Declarations}{=}\initnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHPrimitiveInfo}{}` {
    `\refvar{BVHPrimitiveInfo}{}`(size_t primitiveNumber, const `\refvar{Bounds3f}{}` &bounds)
        : `\refvar{primitiveNumber}{}`(primitiveNumber), `\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`(bounds),
          `\refvar{centroid}{}`(.5f * bounds.`\refvar{pMin}{}` + .5f * bounds.`\refvar{pMax}{}`) { }
    size_t `\initvar{primitiveNumber}{}`;
    `\refvar{Bounds3f}{}` `\initvar[BVHPrimitiveInfo::bounds]{bounds}{}`;
    `\refvar{Point3f}{}` `\initvar{centroid}{}`;
};
\end{lstlisting}

现在可以开始层次构建了。如果选择HLBVH构建算法，则调用\refvar{HLBVHBuild}{()}
构建树。其他三种构建算法都由\refvar{recursiveBuild}{()}负责。
初始调用这些函数时传递了所有要存于树中的图元。
它们返回一个指向树根的指针，用结构体\refvar{BVHBuildNode}{}表示。
树节点应该用提供的\refvar{MemoryArena}{}分配内存，
创建的总数应存于{\ttfamily *totalNodes}中。

树构建过程的一个重要副作用是通过参数{\ttfamily orderedPrims}返回指向图元的新指针数组；
该数组保存了有序的图元这样叶子节点的图元在数组中占有连续的范围。
在树构建后它与原始的\refvar[BVHAccel::primitives]{primitives}{}数组交换。
\begin{lstlisting}
`\initcode{Build BVH tree for primitives using primitiveInfo}{=}`
`\refvar{MemoryArena}{}` arena(1024 * 1024);
int totalNodes = 0;
std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> orderedPrims;
`\refvar{BVHBuildNode}{}` *root;
if (splitMethod == `\refvar{SplitMethod}{}`::`\refvar{HLBVH}{}`)
    root = `\refvar{HLBVHBuild}{}`(arena, primitiveInfo, &totalNodes, orderedPrims);
else
    root = `\refvar{recursiveBuild}{}`(arena, primitiveInfo, 0, `\refvar[BVHAccel::primitives]{primitives}{}`.size(),
                          &totalNodes, orderedPrims);
`\refvar[BVHAccel::primitives]{primitives}{}`.swap(orderedPrims);
\end{lstlisting}

每个\refvar{BVHBuildNode}{}表示一个BVH节点。
所有节点存储一个\refvar{Bounds3f}{}以表示该节点下所有孩子的边界。
每个内部节点在\refvar[BVHBuildNode::children]{children}{}中存有指向其两个孩子的指针。
内部节点也记录图元沿哪个坐标轴划分分给它们的两个孩子；
该信息用于提高遍历算法的性能。
叶子节点需要记录哪个或哪些图元保存在它们中；
数组\refvar{BVHAccel::primitives}{}中从偏移量\refvar{firstPrimOffset}{}起
直到但不包括{\ttfamily\refvar{firstPrimOffset}{}+\refvar[BVHBuildNode:nPrimitives]{nPrimitives}{}}的元素是叶子中的元素
（因此需要记录图元数组，这样就可以利用该表示，
而不是例如在每个叶子节点中保存一个大小可变的图元索引数组）。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastnext{BVHAccelLocalDeclarations}`
struct `\initvar{BVHBuildNode}{}` {
    `\refcode{BVHBuildNode Public Methods}{}`
    `\refvar{Bounds3f}{}` `\initvar[BVHBuildNode::bounds]{bounds}{}`;
    `\refvar{BVHBuildNode}{}` *`\initvar[BVHBuildNode::children]{children}{}`[2];
    int `\initvar[BVHBuildNode::splitAxis]{splitAxis}{}`, `\initvar{firstPrimOffset}{}`, `\initvar[BVHBuildNode:nPrimitives]{nPrimitives}{}`;
};
\end{lstlisting}

我们将通过其孩子指针是否有值{\ttfamily nullptr}来分别区分叶子和内部节点。
\begin{lstlisting}
`\initcode{BVHBuildNode Public Methods}{=}\initnext{BVHBuildNodePublicMethods}`
void `\initvar[BVHBuildNode::InitLeaf]{InitLeaf}{}`(int first, int n, const `\refvar{Bounds3f}{}` &b) {
    `\refvar{firstPrimOffset}{}` = first;
    `\refvar[BVHBuildNode:nPrimitives]{nPrimitives}{}` = n;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = b;
    `\refvar[BVHBuildNode::children]{children}{}`[0] = `\refvar[BVHBuildNode::children]{children}{}`[1] = nullptr;
}
\end{lstlisting}

方法\refvar[BVHBuildNode::InitInterior]{InitInterior}{()}要求已创建两个孩子节点，这样它们的指针才能传入。
该要求让计算内部节点的边界更加容易了，因为孩子的边界可以立刻获得。
\begin{lstlisting}
`\refcode{BVHBuildNode Public Methods}{+=}\lastcode{BVHBuildNodePublicMethods}`
void `\initvar[BVHBuildNode::InitInterior]{InitInterior}{}`(int axis, `\refvar{BVHBuildNode}{}` *c0, `\refvar{BVHBuildNode}{}` *c1) {
    `\refvar[BVHBuildNode::children]{children}{}`[0] = c0;
    `\refvar[BVHBuildNode::children]{children}{}`[1] = c1;
    `\refvar[BVHBuildNode::bounds]{bounds}{}` = `\refvar[Union2]{Union}{}`(c0->`\refvar[BVHBuildNode::bounds]{bounds}{}`, c1->`\refvar[BVHBuildNode::bounds]{bounds}{}`);
    `\refvar[BVHBuildNode::splitAxis]{splitAxis}{}` = axis;
    `\refvar[BVHBuildNode:nPrimitives]{nPrimitives}{}` = 0;
}
\end{lstlisting}

除了用于分配节点和\refvar{BVHPrimitiveInfo}{}结构体数组的\refvar{MemoryArena}{}外，\linebreak
\refvar{recursiveBuild}{()}接收范围参数{\ttfamily[start,end)}。
它负责为从{\ttfamily primitiveInfo [start]}直到并包括{\ttfamily primitiveInfo[end-1]}的
范围表示的图元子集返回一个BVH。
如果该范围只含有单个图元，则递归触底并创建一个叶子节点。
否则，该方法用划分算法之一来划分数组该范围内的元素并相应地重新排列它们，
这样范围{\ttfamily[start,mid)}和{\ttfamily[mid,end)}表示分开的子集。
如果划分成功，则这两个图元集合又传入将会为当前节点的两个孩子返回节点指针的递归调用。

{\ttfamily totalNodes}跟踪已创建的BVH节点总数；
利用该数目使得之后可以分配数目恰好正确的更紧实的\refvar{LinearBVHNode}{}。
最终，数组{\ttfamily orderedPrims}用于保存图元引用就像图元存于树的叶子节点一样。
该数组初始化为空；当创建一个叶子节点时，\refvar{recursiveBuild}{()}把
与之重合的图元添加到数列末尾，让叶子节点可以只存储对该数组的偏移量以及
表示与之重合的图元集的图元数量。
回想当完成树构建时，用这里创建的有序图元数组代替\refvar{BVHAccel::primitives}{}。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
`\refvar{BVHBuildNode}{}` *`\refvar{BVHAccel}{}`::`\initvar{recursiveBuild}{}`(`\refvar{MemoryArena}{}` &arena,
        std::vector<`\refvar{BVHPrimitiveInfo}{}`> &primitiveInfo, int start,
        int end, int *totalNodes,
        std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &orderedPrims) {
    `\refvar{BVHBuildNode}{}` *node = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{BVHBuildNode}{}`>();
    (*totalNodes)++;
    `\refcode{Compute bounds of all primitives in BVH node}{}`
    int nPrimitives = end - start;
    if (nPrimitives == 1) {
        `\refcode{Create leaf BVHBuildNode}{}`
    } else {
        `\refcode{Compute bound of primitive centroids, choose split dimension dim}{}`
        `\refcode{Partition primitives into two sets and build children}{}`
    }
    return node;
}
\end{lstlisting}
\begin{lstlisting}
`\initcode{Compute bounds of all primitives in BVH node}{=}`
`\refvar{Bounds3f}{}` bounds;
for (int i = start; i < end; ++i)
    bounds = `\refvar[Union2]{Union}{}`(bounds, primitiveInfo[i].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
\end{lstlisting}

在叶子节点处，与该叶子重合的图元被添到{\ttfamily orderedPrims}数组末尾并初始化一个叶子节点对象。
\begin{lstlisting}
`\initcode{Create leaf BVHBuildNode}{=}`
int firstPrimOffset = orderedPrims.size();
for (int i = start; i < end; ++i) {
    int primNum = primitiveInfo[i].`\refvar{primitiveNumber}{}`;
    orderedPrims.push_back(`\refvar[BVHAccel::primitives]{primitives}{}`[primNum]);
}
node->`\refvar[BVHBuildNode::InitLeaf]{InitLeaf}{}`(firstPrimOffset, nPrimitives, bounds);
return node;
\end{lstlisting}

对于内部节点，一组图元必须在两个子树之间划分。
给定$n$个图元，有$2^{n-1}-1$种\sidenote{译者注：原文误写为$2(n-1)-2$，已修正。}
可能的方法将它们划分到两个非空组。
实际中构建BVH时，一般考虑沿一个坐标轴划分，这意味着大约有$3n$个候选划分
（沿每个轴方向，每个图元可能放到第一分区或第二分区）。

这里我们就选择三个坐标轴的一个用来划分图元。
当为当前图元集合投影边界框形心时，我们选择有最大范围的轴
（另一种是尝试所有三个轴并选择给出最好结果的那个，但实际中本方法更好）。
该方法在许多场景下给出良好划分；\reffig{4.3}说明了该策略。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHchoosesplitaxis.tex}
    \caption{选择沿哪个轴划分图元。\protect\refvar{BVHAccel}{}基于
        图元边界框形心在哪个轴有最大范围来选择划分图元所沿的轴。
        这里在二维中，它们沿$y$轴的范围最大（轴上的实心点），所以图元会在$y$上划分。}
    \label{fig:4.3}
\end{figure}

这里划分的一般目标是选择图元的一个划分使得
得到的两个图元集合的边界框没有太多重合——
如果有大量重合则在遍历树时它需要更频繁地遍历两个子树，
比起本应可以更高效剪除一些图元它需要更多计算量。
待会儿在讨论表面积启发法时会更严谨地表述该求取高效图元划分的思想。
\begin{lstlisting}
`\initcode{Compute bound of primitive centroids, choose split dimension dim}{=}`
`\refvar{Bounds3f}{}` centroidBounds;
for (int i = start; i < end; ++i)
    centroidBounds = `\refvar[Union2]{Union}{}`(centroidBounds, primitiveInfo[i].`\refvar{centroid}{}`);
int dim = centroidBounds.`\refvar{MaximumExtent}{}`();
\end{lstlisting}

如果所有形心点都在同一位置（即形心边界为零体积），
则递归停止并用该图元创建一个叶子结点；
这里没有划分方法能对那种（非常）情况有效。
否则用选择的方法划分图元并传入两个对\refvar{recursiveBuild}{()}的递归调用。
\begin{lstlisting}
`\initcode{Partition primitives into two sets and build children}{=}`
int mid = (start + end) / 2;
if (centroidBounds.`\refvar{pMax}{}`[dim] == centroidBounds.`\refvar{pMin}{}`[dim]) {
    `\refcode{Create leaf BVHBuildNode}{}`
} else {
    `\refcode{Partition primitives based on splitMethod}{}`
    node->`\refvar[BVHBuildNode::InitInterior]{InitInterior}{}`(dim,
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, start, mid,
                                      totalNodes, orderedPrims),
                       `\refvar{recursiveBuild}{}`(arena, primitiveInfo, mid, end,
                                      totalNodes, orderedPrims));
}
\end{lstlisting}

代码片\refcode{Partition primitives based on splitMethod}{}只是用
\refvar[splitMethod]{BVHAccel::splitMethod}{}
的值决定该用哪个图元划分方案。接下来的几页将介绍这三个方案。
\begin{lstlisting}
`\initcode{Partition primitives based on splitMethod}{=}`
switch (`\refvar{splitMethod}{}`) {
case `\refvar{SplitMethod}{}`::`\refvar{Middle}{}`: {
    `\refcode{Partition primitives through node's midpoint}{}`
}
case `\refvar{SplitMethod}{}`::`\refvar{EqualCounts}{}`: {
    `\refcode{Partition primitives into equally sized subsets}{}`
    break;
}
case `\refvar{SplitMethod}{}`::`\refvar{SAH}{}`:
default: {
    `\refcode{Partition primitives using approximate SAH}{}`
    break;
}
}
\end{lstlisting}

\refvar{Middle}{}是一个简单的\refvar{SplitMethod}{}，
它首先计算图元形心沿划分轴的中点。
该方法在代码片\refcode{Partition primitives through node's midpoint}{}中实现。
图元按其形心在中点之上还是之下分为两个集合。
该划分用C++标准库函数{\ttfamily std::partition()}很容易完成，
它接收数组中的一系列元素和比较函数，并对数组元素排序使得
对于判定函数而言所有返回{\ttfamily true}的元素都出现在返回{\ttfamily false}的范围之前
\footnote{在调用{\ttfamily std::partition()}时，
注意数组{\ttfamily primitiveInfo}索引的特殊表达式即{\ttfamily \&primitiveInfo[end-1]+1}。
这样写代码有些晦涩的理由。在C和C++程序语言中，
计算数组末尾后下一个元素的指针是合法的，
这样遍历数组元素能持续到当前指针等于末端点。
为此，我们这里想就写成表达式{\ttfamily \&primitiveInfo[end]}。
然而{\ttfamily primitiveInfo}分配为C++的{\ttfamily vector}；
一些{\ttfamily vector}实现在传给其{\ttfamily []}操作符
的偏移量是在数组末端之后时会报运行时错误。
因为我们不会尝试引用数组末端后下一个元素的值而只是想计算其地址，
所以该操作事实上是安全的。
因此我们最终用这里的表达式计算同一地址，并且也满足任何{\ttfamily vector}错误检查。}。
{\ttfamily std::partition()}返回指向第一个对于判定有{\ttfamily false}值的元素的指针，
它转化为对数组{\ttfamily primitiveInfo}的偏移量，这样我们就可以将其传入递归调用。
\reffig{4.4}说明了该方法，包括其有效和无效的情况。

如果图元都有巨大的重叠边界框，则该划分方法可能无法把图元分为两组。
这种情况下，执行往下进入{\ttfamily \refvar{SplitMethod}{}::\refvar{EqualCounts}{}}方法再试一次。
\begin{lstlisting}
`\initcode{Partition primitives through node's midpoint}{=}`
`\refvar{Float}{}` pmid = (centroidBounds.`\refvar{pMin}{}`[dim] + centroidBounds.`\refvar{pMax}{}`[dim]) / 2;
`\refvar{BVHPrimitiveInfo}{}` *midPtr =
    std::partition(&primitiveInfo[start], &primitiveInfo[end-1]+1,
        [dim, pmid](const `\refvar{BVHPrimitiveInfo}{}` &pi) {
            return pi.`\refvar{centroid}{}`[dim] < pmid;
        });
mid = midPtr - &primitiveInfo[0];
if (mid != start && mid != end)
    break;
\end{lstlisting}

当\refvar{splitMethod}{}是{\ttfamily\refvar{SplitMethod}{}::\refvar{EqualCounts}{}}时，
则运行代码片\refcode{Partition primitives into equally sized subsets}{}。
它把图元划分为两个数量相等的子集使得$n$个中前一半的$\displaystyle\frac{n}{2}$个
沿所选轴的形心坐标最小，另一半的则有最大形心坐标值。
尽管该方法有时能起效，但也有\reffig{4.4}(b)效果不好的情况。
\begin{figure}[htb]
    \centering\input{Pictures/chap04/Midpointgoodbadsplit.tex}
    \caption{一轴上基于形心中点划分图元。(a)对于一些图元分布，
        例如这里所示，沿所选轴（粗蓝线）基于形心中点的划分效果很好。
        (b)对于像这个的分布，中点是次优选项；所得两个边界框大量重叠。
        (c)若来自(b)的同一组图元换为用这里展示的线分开，所得边界框
        更小且根本不会重叠，使渲染时性能更好。}
    \label{fig:4.4}
\end{figure}

该方案也易于调用标准库的{\ttfamily std::nth\_element()}实现。
它接收起点、中点和终点指针以及一个比较函数。
它对数组排序使得中点指针处元素的位置是，如果数组完全排序，
则所有中点之前的元素都比中点元素小且所有后面的元素都比它大。
对于$n$个元素该排序可以在$O(n)$时间内完成，
比完全排序数组的$O(n\log{n})$更高效。
\begin{lstlisting}
`\initcode{Partition primitives into equally sized subsets}{}`
mid = (start + end) / 2;
std::nth_element(&primitiveInfo[start], &primitiveInfo[mid], 
                 &primitiveInfo[end-1]+1,
    [dim](const BVHPrimitiveInfo &a, const BVHPrimitiveInfo &b) { 
        return a.`\refvar{centroid}{}`[dim] < b.`\refvar{centroid}{}`[dim];
    });
\end{lstlisting}

\subsection{表面积启发法}\label{sub:表面积启发法}
上述两个图元划分方法对一些图元分布效果不错，
但实际中它们经常选择性能较差的划分，导致光线要访问树的更多节点，
因此带来渲染时不必要的低效光线-图元相交计算。
当下光线追踪大部分最好的构建加速结构算法都基于“\keyindex{表面积启发法}{surface area heuristic}{}”(SAH)，
它提供了全面的开销模型来回答问题，例如
“大量图元划分中哪个会为光线-图元相交测试带来更好的BVH？”，
或者“在空间划分方案里大量划分空间的可选位置中哪个会带来更好的加速结构？”

SAH模型估计执行光线相交测试的开销，包括穿行树的节点花的时间和
为特定的图元划分进行光线-图元相交测试花的时间。
然后构建加速结构的算法可以遵循最小化总开销的目标。
通常用贪婪算法独立地为正在构建的每个层次节点最小化开销。

SAH开销模型背后的思想很简单：构建自适应加速结构（图元划分或空间划分）的任意点处，
我们可以为当前区域和几何体创建一个叶子结点。
这种情况下，任何穿过该区域的光线都要对所有重合的图元测试，
且带来的开销为
\begin{align*}
    \sum\limits_{i=1}^{N}{t_{\mathrm{isect}}(i)}\, ,
\end{align*}
其中$N$是图元数量，$t_{\mathrm{isect}}(i)$是对第$i$个图元计算光线-物体相交的时间。

另一选项是划分该空间。这种情况下，光线会带来开销
\begin{align}\label{eq:4.1}
    c(A,B)=t_{\mathrm{trav}}+p_A\sum\limits_{i=1}^{N_A}{t_\mathrm{isect}(a_i)}+p_B\sum\limits_{i=1}^{N_B}{t_{\mathrm{isect}}(b_i)}\, ,
\end{align}
其中$t_{\mathrm{trav}}$是穿行内部节点并确定光线穿过哪个子树所花的时间，分别地，
$p_A$和$p_B$是光线穿过每个子节点（假设二分划分）的概率，
$a_i$和$b_i$是两个子节点中图元的索引，
$N_A$和$N_B$是与两个子节点区域重合的图元数量。
怎样划分图元的选项会影响两个概率值以及划分出的两边的图元集合。

pbrt中，我们将作出简化假设即所有图元的$t_{\mathrm{trav}}(i)$都相同；
该假设可能和实际差不了多少，且它引入的任何误差看起来并不太影响加速器的性能。
另一种可能是向\refvar{Primitive}{}添加一个方法返回估计的相交测试所需的CPU周期数。

概率$p_A$和$p_B$可用来自几何概型的思想计算。
可以证明当凸体$A$包含于另一凸体$B$中，
穿过$B$的均匀分布的随机光线也穿过$A$的条件概率是它们表面积$s_A$与$s_B$的比：
\begin{align*}
    \displaystyle p(A|B)=\frac{s_A}{s_B}\, .
\end{align*}

因为我们对光线穿过节点的开销感兴趣，我们可以直接利用该结果。
因此，如果我们考虑细化一空间区域$A$使得有两个新子区域边界为$B$和$C$（\reffig{4.5}），
则穿过$A$的光线也会穿过两个子区域之一的概率很容易计算。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/Surfaceareasplit.tex}
    \caption{如果边界层次一个表面积为$s_A$的节点分为两个表面积为$s_B$和$s_C$的孩子，
        则穿过$A$的光线也穿过$B$和$C$的概率分别为$\displaystyle\frac{s_B}{s_A}$和$\displaystyle\frac{s_C}{s_A}$.}
    \label{fig:4.5}
\end{figure}

当\refvar{splitMethod}{}值为{\ttfamily\refvar{SplitMethod}{}::\refvar{SAH}{}}时，SAH用于构建BVH；
通过考虑大量候选划分来寻找沿所选轴给出最小SAH估计开销的图元划分
（这是默认\refvar{SplitMethod}{}，且它为渲染创建最高效的树）。
然而，一旦它细分少量图元，则实现切换为划分成等量的子集。
这时应用SAH所增加的计算量是不划算的。
\begin{lstlisting}
`\initcode{Partition primitives using approximate SAH}{=}`
if (nPrimitives <= 4) {
    `\refcode{Partition primitives into equally sized subsets}{}`
} else {
    `\refcode{Allocate BucketInfo for SAH partition buckets}{}`
    `\refcode{Initialize BucketInfo for SAH partition buckets}{}`
    `\refcode{Compute costs for splitting after each bucket}{}`
    `\refcode{Find bucket to split at that minimizes SAH metric}{}`
    `\refcode{Either create leaf or split primitives at selected SAH bucket}{}`
}
\end{lstlisting}

比起穷举沿该轴所有$2^n$个可能的划分
\sidenote{译者注：原文写作$2n$，笔者认为是笔误，已修正。}，
这里的实现是将沿该轴的范围分为少量相等的较大范围，并为每个计算SAH以选择最好的。
然后它只考虑在该范围边界内的划分。
该方法比考虑所有划分更高效且通常仍产出几乎一样高效的划分。
\reffig{4.6}说明了该思想。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHsplitbucketing.tex}
    \caption{用表面积启发法为BVH选择划分平面。图元边界形心的投影范围被投影在选定的划分轴上。
        每个图元都基于其边界形心被放在沿轴的一个桶中。
        然后实现会估计沿每个桶的边界（粗蓝线）的平面划分图元的开销；
        谁的表面积启发法开销最小就选谁。}
    \label{fig:4.6}
\end{figure}
\begin{lstlisting}
`\initcode{Allocate BucketInfo for SAH partition buckets}{=}`
constexpr int nBuckets = 12;
struct `\initvar{BucketInfo}{}` {
    int `\initvar[BucketInfo::count]{count}{}` = 0;
    `\refvar{Bounds3f}{}` `\initvar[BucketInfo::bounds]{bounds}{}`;
};
`\refvar{BucketInfo}{}` buckets[nBuckets];
\end{lstlisting}

对于该范围内的每个图元，我们确定包含其形心的桶\protect\sidenote{译者注：原文bucket。}并更新桶的边界以包含图元的边界。
\begin{lstlisting}
`\initcode{Initialize BucketInfo for SAH partition buckets}{=}`
for (int i = start; i < end; ++i) {
    int b = nBuckets * 
        centroidBounds.`\refvar{Offset}{}`(primitiveInfo[i].`\refvar{centroid}{}`)[dim];
    if (b == nBuckets) b = nBuckets - 1;
    buckets[b].`\refvar[BucketInfo::count]{count}{}`++;
    buckets[b].`\refvar[BucketInfo::bounds]{bounds}{}` = `\refvar[Union2]{Union}{}`(buckets[b].`\refvar[BucketInfo::bounds]{bounds}{}`, primitiveInfo[i].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
}
\end{lstlisting}

对于每个桶，我们现在都有图元数量以及全部相应边界框的边界。
我们想用SAH估计在每个桶边界处作划分的开销。
下面的代码片遍历所有桶并初始化数组{\ttfamily cost[i]}来
保存估计的在第{\ttfamily i}个桶后划分的SAH开销
（不考虑在最后一个桶之后划分，因为根据定义它并不划分图元）。

我们任意设置估计的相交开销为1，然后设置估计的遍历开销
为$\displaystyle\frac{1}{8}$（两者之一总是可以设为1，
因为是估计的遍历和相交开销的相对量级而不是绝对量级决定其影响）。
尽管遍历节点即光线-边界框相交的绝对计算量仅稍低于光线与形状相交所需的计算量，
但pbrt中光线-图元相交测试经过了两次虚函数调用，增加了大量开销，
所以这里我们估计其开销大于光线-框相交的八倍。

基于对桶前向和后向扫描而增量式地计算、存储和计数边界的线性时间实现是可能的，
但这里的计算关于桶的数量有$O(n^2)$复杂度。
更加高度优化解决该低效问题的渲染器是值得的，
但这里对于小的$n$，性能影响通常是可接受的。
\begin{lstlisting}
`\initcode{Compute costs for splitting after each bucket}{=}`
`\refvar{Float}{}` cost[nBuckets - 1];
for (int i = 0; i < nBuckets - 1; ++i) {
    `\refvar{Bounds3f}{}` b0, b1;
    int count0 = 0, count1 = 0;
    for (int j = 0; j <= i; ++j) {
        b0 = `\refvar[Union2]{Union}{}`(b0, buckets[j].`\refvar[BucketInfo::bounds]{bounds}{}`);
        count0 += buckets[j].`\refvar[BucketInfo::count]{count}{}`;
    }
    for (int j = i+1; j < nBuckets; ++j) {
        b1 = `\refvar[Union2]{Union}{}`(b1, buckets[j].`\refvar[BucketInfo::bounds]{bounds}{}`);
        count1 += buckets[j].`\refvar[BucketInfo::count]{count}{}`;
    }
    cost[i] = .125f + (count0 * b0.`\refvar{SurfaceArea}{}`() +
                       count1 * b1.`\refvar{SurfaceArea}{}`()) / bounds.`\refvar{SurfaceArea}{}`();
}
\end{lstlisting}

有了所有开销，对数组{\ttfamily cost}的线性扫描找到最小开销的划分。
\begin{lstlisting}
`\initcode{Find bucket to split at that minimizes SAH metric}{=}`
`\refvar{Float}{}` minCost = cost[0];
int minCostSplitBucket = 0;
for (int i = 1; i < nBuckets - 1; ++i) {
    if (cost[i] < minCost) {
        minCost = cost[i];
        minCostSplitBucket = i;
    }
}
\end{lstlisting}

如果为划分选的桶边界有比用存在的图元构建节点更低的估计开销，
或者出现一个节点的图元超过了允许的最大数量，
则用函数{\ttfamily std::partition()}来完成
在数组{\ttfamily primitiveInfo}中记录节点的工作。
回想之前它的用法即该函数确保数组的所有对于给定判定函数返回{\ttfamily true}的元素
都出现在返回{\ttfamily false}的之前，
并且它返回指向第一个判定函数返回{\ttfamily false}的元素的指针。
因为我们之前任意设置估计的相交开销为1，
所以只是创建叶子结点的估计开销等于图元的数量{\ttfamily nPrimitives}。
\begin{lstlisting}
`\initcode{Either create leaf or split primitives at selected SAH bucket}{=}`
`\refvar{Float}{}` leafCost = nPrimitives;
if (nPrimitives > maxPrimsInNode || minCost < leafCost) {
    `\refvar{BVHPrimitiveInfo}{}` *pmid = std::partition(&primitiveInfo[start],
        &primitiveInfo[end-1]+1, 
        [=](const `\refvar{BVHPrimitiveInfo}{}` &pi) {
            int b = nBuckets * centroidBounds.`\refvar{Offset}{}`(pi.centroid)[dim];
            if (b == nBuckets) b = nBuckets - 1;
            return b <= minCostSplitBucket;
        });
    mid = pmid - &primitiveInfo[0];
} else {
    `\refcode{Create leaf BVHBuildNode}{}`
}
\end{lstlisting}

\subsection{线性包围盒层次}\label{sub:线性包围盒层次}
尽管用表面积启发法构建包围盒层次给出了很好的结果，
但该方法有两个缺点：第一，接收了许多传入的场景图元来在树的所有层次上计算SAH开销。
第二，自顶向下的BVH构建难以很好地并行化：
最明显的并行化方法——执行独立子树的并行化构建——
在直到该树顶部几层构建好前都受困于有限的独立任务，
这反过来又抑制了并行的可扩展性
（第二个问题在GPU上尤为突出，如果大规模并行化不可用则性能会很差）。

开发\keyindex{线性包围盒层次}{linear bounding volume hierarchy}{}(LBVH)来解决这些问题。
通过LBVH，以传递轻量级小次数的图元来构建树；
树的构建时间与图元数量呈线性关系。
而且算法快速地把图元划分为可以独立处理的\keyindex{群集}{cluster}{}。
该过程很容易并行化且很适合GPU实现。

LBVH背后的关键思想是把BVH构建变为排序问题。
因为没有排序多维数据的单一顺序函数，所以LBVH是基于\keyindex{莫顿码}{Morton code}{}的，
它将$n$维中的邻近点映射为1D直线上的邻近点，使之有明显的排序函数。
在图元排序后，空间上相邻的图元群集在排序数组的连续段内。

莫顿码基于简单的变换：给定$n$维整数坐标值，
其莫顿码表示由交错二进制坐标数位求得。
例如，考虑一个2D坐标$(x,y)$，其中$x$和$y$的数位表示为$x_i$和$y_i$.
相应的莫顿码值为
\begin{align*}
    \cdots y_3x_3y_2x_2y_1x_1y_0x_0\, .
\end{align*}

\reffig{4.7}展示了2D点按莫顿顺序的图示——
注意沿递归的“z”形路径访问它们
（因此莫顿路径有时也称为“z序”）。
我们可以看到2D中坐标相近的点通常在莫顿曲线上也是相近的
\footnote{许多GPU用莫顿布局在内存中存储纹理贴图。
    这样做的一个优点是当在四个纹素值之间执行双线性插值时，
    比起纹理按扫描线顺序排布，这些值更有极大可能在内存中相邻。
    反过来，这有利于纹理缓存性能。}。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/MortonBasic.tex}
    \caption{沿莫顿曲线访问点的顺序。沿$x$和$y$轴的坐标值用二进制表示。
        如果我们按其莫顿索引的顺序连接整数坐标点，我们可以看见莫顿曲线沿分层级的“z”形路径访问这些点。}
    \label{fig:4.7}
\end{figure}

莫顿编码值也编码了关于点所表示的位置的有用信息。
考虑2D中4位坐标值的情况：$x$和$y$坐标是$[0,15]$内的整数且
莫顿码有8位：$y_3x_3y_2x_2y_1x_1y_0x_0$.
编码会得出许多整数性质；一些例子包括：
\begin{itemize}
    \item 对于莫顿编码8位值中高位$y_3$置位的，我们就知道
          其本身的$y$坐标高位置位且因此$y\ge8$（\reffig{4.8}(a)）。
    \item 下一位值$x_3$在中间划分$x$轴（\reffig{4.8}(b)）。
          例如如果$y_3$置位而$x_3$没有，则相应的点一定位于\reffig{4.8}(c)的阴影区。
          具有许多高位匹配的点通常位于由匹配位值决定的幂2边长的对齐空间区域。
    \item $y_2$值将$y$轴划分为四个区域（\reffig{4.8}(d)）。
\end{itemize}
\begin{figure}[htb]
    \centering\input{Pictures/chap04/MortonBinary.tex}\\
    \input{Pictures/chap04/MortonSplitHoriz.tex}
    \input{Pictures/chap04/MortonSplitVert.tex}
    \input{Pictures/chap04/MortonShadedRegion.tex}\\
    \input{Pictures/chap04/MortonSplitHoriz3.tex}
    \caption{莫顿编码的实现。莫顿值中不同位的值表示相应坐标所在的空间区域。
        (a)在2D中，一个点坐标的莫顿编码值高位定义了沿$y$轴中点的划分平面。
        如果该高位置位，则点在平面以上。(b)同样，莫顿值的第二高位在中间划分$x$轴。
        (c)如果高$y$位是1且高$x$位是0，则该点一定在阴影区域内。
        (d)第二高$y$位把$y$轴划分为四个区域。}
    \label{fig:4.8}
\end{figure}

另一个解释这些基于数位的性质的方法是按莫顿编码值来。
例如，\reffig{4.8}(a)对应在范围$[8,15]$内的索引，
\reffig{4.8}(c)对应$[8,11]$.因此，给定一组排序了的莫顿索引，
我们可以通过二分搜索找到对应于像\reffig{4.8}(c)区域那样的点的范围，
以在数组中找到每个终点。

LBVH是通过用每个空间区域中点处的划分平面
（即等价于之前定义的路径\refvar[Middle]{SplitMethod::Middle}{}）划分图元而构建的BVH。
因为它基于上述的莫顿编码性质，所以划分非常高效。

仅仅以不同方式复现\refvar{Middle}{}并不有趣，所以这里的实现中我们将
构建\keyindex{分层线性包围盒层次}{hierarchical linear bounding volume hierarchy}{linear bounding volume hierarchy\ 线性包围盒层次}(HLBVH)。
通过该方法首先用基于莫顿曲线的聚类为低层级构建树（以下称“小树”\sidenote{译者注：原文treelet。}），
然后用表面积启发法创建高层级树。
方法\refvar{HLBVHBuild}{()}实现了该方法并返回所得树的根节点。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
`\refvar{BVHBuildNode}{}` *`\refvar{BVHAccel}{}`::`\initvar{HLBVHBuild}{}`(`\refvar{MemoryArena}{}` &arena, 
        const std::vector<`\refvar{BVHPrimitiveInfo}{}`> &primitiveInfo,
        int *totalNodes,
        std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &orderedPrims) const {
    `\refcode{Compute bounding box of all primitive centroids}{}`
    `\refcode{Compute Morton indices of primitives}{}`
    `\refcode{Radix sort primitive Morton indices}{}`
    `\refcode{Create LBVH treelets at bottom of BVH}{}`
    `\refcode{Create and return SAH BVH from LBVH treelets}{}`
}
\end{lstlisting}

只用图元边界框形心构建BVH来对其排序——
它不考虑每个图元的实际空间范围。
该简化对HLBVH提供的性能很关键，
但它也意味着对于一些占有很大尺寸范围的场景而言，
构建的树不会像基于SAH的树那样考虑这些特例。

因为莫顿编码在整数坐标上操作，我们首先需要定界所有图元的形心，
这样我们就可以量化相对于整体边界的形心位置。
\begin{lstlisting}
`\initcode{Compute bounding box of all primitive centroids}{=}`
`\refvar{Bounds3f}{}` bounds;
for (const `\refvar{BVHPrimitiveInfo}{}` &pi : primitiveInfo)
    bounds = `\refvar[Union2]{Union}{}`(bounds, pi.`\refvar{centroid}{}`);
\end{lstlisting}

有了整体边界，我们现在可以为每个图元计算莫顿码了。
这是非常轻量的计算，但假定可能有数百万图元，则它是值得并行化的。
注意下面把512的循环块尺寸传入\refvar{ParallelFor}{()}；
这让工作线程每次要处理512组图元而不是默认的一组。
因为每个图元计算莫顿码要执行的工作量相对较小，
这粒度更好地把分布式任务的开销分摊给了工作线程。
\begin{lstlisting}
`\initcode{Compute Morton indices of primitives}{=}`
std::vector<`\refvar{MortonPrimitive}{}`> mortonPrims(primitiveInfo.size());
`\refvar{ParallelFor}{}`(
    [&](int i) {
        `\refcode{Initialize mortonPrims[i] for ith primitive}{}`
    }, primitiveInfo.size(), 512);
\end{lstlisting}

为每个图元都创建一个实例\refvar{MortonPrimitive}{}；
它保存了图元在数组\newline{\ttfamily primitiveInfo}中的图元索引及其莫顿码。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastnext{BVHAccelLocalDeclarations}`
struct `\initvar{MortonPrimitive}{}` {
    int `\initvar{primitiveIndex}{}`;
    uint32_t `\initvar{mortonCode}{}`;
};
\end{lstlisting}

我们为每个$x$、$y$和$z$坐标用10位数，这样莫顿码一共30位。
该粒度允许值与单个32位变量相容。
边界框内的浮点形心偏移量在$[0,1]$内，
所以我们用$2^{10}$缩放它们得到10位表示的整数坐标
（对于恰等于1的边界情况，可能得到出界的量化值1024；
这种情况在即将介绍的函数\refvar{LeftShift3}{()}中处理）。
\begin{lstlisting}
`\initcode{Initialize mortonPrims[i] for ith primitive}{=}`
constexpr int mortonBits = 10;
constexpr int mortonScale = 1 << mortonBits;
mortonPrims[i].`\refvar{primitiveIndex}{}` = primitiveInfo[i].`\refvar{primitiveNumber}{}`;
`\refvar{Vector3f}{}` centroidOffset = bounds.`\refvar{Offset}{}`(primitiveInfo[i].`\refvar{centroid}{}`);
mortonPrims[i].`\refvar{mortonCode}{}` = `\refvar{EncodeMorton3}{}`(centroidOffset * mortonScale);
\end{lstlisting}

为计算3D莫顿码，首先我们定义一个辅助函数：\refvar{LeftShift3}{()}接收
一个32位值并返回把第$i$位移到第$3i$位的结果，剩下位为零。
\reffig{4.9}说明了该操作。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.75\linewidth]{chap04/LeftShift3.eps}
    \caption{移位以计算3D莫顿码。函数\refvar{LeftShift3}{()}接收32位整数值，
        且对于低10位，把第$i$位移到第$3i$位的位置——换句话说，向左移$2i$位。剩下全部位设为零。}
    \label{fig:4.9}
\end{figure}

实现该操作最明显的方法，即单独移动每一位，并不是最高效的
（它需要总共9次位移以及逻辑或来计算最终值）。
取而代之的是，我们可以把每位的移动分解为多个幂2尺寸的移位且一并把数位值移到其最终位置。
然后，所有需要移动给定幂2数位的位可以一并移动。
函数\refvar{LeftShift3}{()}实现了该计算，\reffig{4.10}展示了它如何工作的
\sidenote{译者注：原图第4行“9”的位置有误，此处已修正。}。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.75\linewidth]{Pictures/chap04/Mortonpow2decomposition.eps}
    \caption{莫顿移位的幂2分解。通过一系列幂2尺寸的移动来为每个3D坐标计算莫顿码执行移位。
        首先，位8和9向左移16位，这把位8放在了其最终位置。接着位4到7移动8位。
        移动4和2位后（适当掩模使每位最终都移动适当数位），所有数位都在正确的位置上。
        该计算由函数\refvar{LeftShift3}{()}实现。}
    \label{fig:4.10}
\end{figure}

\begin{lstlisting}
`\initcode{BVHAccel Utility Functions}{=}\initnext{BVHAccelUtilityFunctions}`
inline uint32_t `\initvar{LeftShift3}{}`(uint32_t x) {
    if (x == (1 << 10)) --x;
    x = (x | (x << 16)) & 0b00000011000000000000000011111111;
    x = (x | (x <<  8)) & 0b00000011000000001111000000001111;
    x = (x | (x <<  4)) & 0b00000011000011000011000011000011;
    x = (x | (x <<  2)) & 0b00001001001001001001001001001001;
    return x;
}
\end{lstlisting}

\refvar{EncodeMorton3}{()}接收每个分量都是$0$到$2^{10}$之间浮点值的3D坐标值。
它把这些值转换为整数然后通过展开三个10位量化值使第$i$位在位置$3i$上来计算莫顿码，
然后$y$位再移一位，$z$位再移两位，全部结果求或（\reffig{4.11}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.75\linewidth]{chap04/Mortonxyzinterleave.eps}
    \caption{最终交错坐标值。有了\refvar{LeftShift3}{()}为$x$、$y$和$z$计算的交错值，
        最终莫顿编码值通过分别移动$y$和$z$一位和两位然后全部结果求或算得。}
    \label{fig:4.11}
\end{figure}

\begin{lstlisting}
`\refcode{BVHAccel Utility Functions}{+=}\lastnext{BVHAccelUtilityFunctions}`
inline uint32_t `\initvar{EncodeMorton3}{}`(const `\refvar{Vector3f}{}` &v) {
    return (`\refvar{LeftShift3}{}`(v.z) << 2) | (`\refvar{LeftShift3}{}`(v.y) << 1) |
            `\refvar{LeftShift3}{}`(v.x);
}
\end{lstlisting}

一旦计算了莫顿索引，我们将用\keyindex{基数排序}{radix sort}{}按莫顿索引值对
\newline{\ttfamily mortonPrims}排序。
我们已经发现对于BVH的构建，我们的基数排序实现明显快于使用我们系统标准库的{\ttfamily std::sort()}
（它是\keyindex{快速排序}{quicksort}{}和\keyindex{插入排序}{insertion sort}{}的混合）。
\begin{lstlisting}
`\initcode{Radix sort primitive Morton indices}{=}`
`\refvar{RadixSort}{}`(&mortonPrims);
\end{lstlisting}

回想基数排序和大多数排序算法的不同在于它不是基于比较一对值
而是基于依赖一些键值的桶子项。基数排序可用于排序整数值，
它从最右边数位到最左边每次排序一个数码。
它尤其值得每次对二进制值排序多个数码；
这样做减少了传递数据的次数。
这里的实现中，{\ttfamily bitsPerPass}设置每次传递处理的位数；
取值6后，我们有5次传递来排序30位。
\begin{lstlisting}
`\refcode{BVHAccel Utility Functions}{+=}\lastcode{BVHAccelUtilityFunctions}`
static void `\initvar{RadixSort}{}`(std::vector<`\refvar{MortonPrimitive}{}`> *v) {
    std::vector<`\refvar{MortonPrimitive}{}`> tempVector(v->size());
    constexpr int bitsPerPass = 6;
    constexpr int nBits = 30;
    constexpr int nPasses = nBits / bitsPerPass;
    for (int pass = 0; pass < nPasses; ++pass) {
        `\refcode{Perform one pass of radix sort, sorting bitsPerPass bits}{}`
    }
    `\refcode{Copy final result from tempVector, if needed}{}`
}
\end{lstlisting}

当前传递会排序{\ttfamily bitsPerPass}位，从{\ttfamily lowBit}开始。
\begin{lstlisting}
`\initcode{Perform one pass of radix sort, sorting bitsPerPass bits}{=}`
int lowBit = pass * bitsPerPass;
`\refcode{Set in and out vector pointers for radix sort pass}{}`
`\refcode{Count number of zero bits in array for current radix sort bit}{}`
`\refcode{Compute starting index in output array for each bucket}{}`
`\refcode{Store sorted values in output array}{}`
\end{lstlisting}

{\ttfamily in}和{\ttfamily out}引用分别对应于要排序的向量以及保存排序值的向量。
每次通过循环的传递都在输入向量{\ttfamily *v}和临时向量之间交替。
\begin{lstlisting}
`\initcode{Set in and out vector pointers for radix sort pass}{=}`
std::vector<`\refvar{MortonPrimitive}{}`> &in  = (pass & 1) ? tempVector : *v;
std::vector<`\refvar{MortonPrimitive}{}`> &out = (pass & 1) ? *v : tempVector;
\end{lstlisting}

如果我们每次传递中排序$n$位，则每个值可能落入的桶有$2^n$个。
我们先计数每个桶中会落入多少个值；这能让我们确定在输出数组中的何处保存排序值。
为了给当前值计算桶索引，该实现对索引移位使得在索引{\ttfamily lowBit}上的位
位于0号位，再掩模低处{\ttfamily bitsPerPass}个位。
\begin{lstlisting}
`\initcode{Count number of zero bits in array for current radix sort bit}{=}`
constexpr int nBuckets = 1 << bitsPerPass;
int bucketCount[nBuckets] = { 0 };
constexpr int bitMask = (1 << bitsPerPass) - 1;
for (const `\refvar{MortonPrimitive}{}` &mp : in) {
    int bucket = (mp.`\refvar{mortonCode}{}` >> lowBit) & bitMask;
    ++bucketCount[bucket];
}
\end{lstlisting}

有了每个桶中落入值的数量，我们就可以计算在输出数组中
每个桶的值开始处的偏移量；这就是之前的桶中落入值数量的和。
\begin{lstlisting}
`\initcode{Compute starting index in output array for each bucket}{=}`
int outIndex[nBuckets];
outIndex[0] = 0;
for (int i = 1; i < nBuckets; ++i)
    outIndex[i] = outIndex[i - 1] + bucketCount[i - 1];
\end{lstlisting}

现在我们知道每个桶在何处开始排序值了，
可以接收另一次图元传递来重算每个图元所在的桶并
将其\refvar{MortonPrimitive}{}保存在输出数组中。
这为当前这组数位完成了排序传递。
\begin{lstlisting}
`\initcode{Store sorted values in output array}{=}`
for (const `\refvar{MortonPrimitive}{}` &mp : in) {
    int bucket = (mp.`\refvar{mortonCode}{}` >> lowBit) & bitMask;
    out[outIndex[bucket]++] = mp;
}
\end{lstlisting}

当完成排序时，如果执行了奇数次基数排序传递，则最终排序值需要
从临时向量复制到原来传入\refvar{RadixSort}{()}的输出向量。
\begin{lstlisting}
`\initcode{Copy final result from tempVector, if needed}{}`
if (nPasses & 1)
    std::swap(*v, tempVector);
\end{lstlisting}

有了图元排序数组，我们将用附近的形心求得图元群集，
再在每个群集内创建图元上的LBVH。
这一步很适合并行化，因为通常有很多群集且每个群集都可以独立处理。
\begin{lstlisting}
`\initcode{Create LBVH treelets at bottom of BVH}{=}`
`\refcode{Find intervals of primitives for each treelet}{}`
`\refcode{Create LBVHs for treelets in parallel}{}`
\end{lstlisting}

每个图元群集都表示为一个\refvar{LBVHTreelet}{}。
它对群集中第一个图元在{\ttfamily mortonPrims}数组中的索引
以及后续图元的数量进行编码（见\reffig{4.12}）。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastnext{BVHAccelLocalDeclarations}`
struct `\initvar{LBVHTreelet}{}` {
   int `\initvar{startIndex}{}`, `\initvar[LBVHTreelet:nPrimitives]{nPrimitives}{}`;
   `\refvar{BVHBuildNode}{}` *`\initvar{buildNodes}{}`;
};
\end{lstlisting}

\begin{figure}[htbp]
    \centering\input{Pictures/chap04/LBVHtreeletclusters.tex}
    \caption{LBVH小树的图元群集。图元形心聚类到覆盖其边界的均匀网格内。
        为每个格子中位于排序后的莫顿索引值连续段内的图元群集创建LBVH。}
    \label{fig:4.12}
\end{figure}

回想\reffig{4.8}中，莫顿码高位值匹配的点集位于原始盒中一个幂2对齐和幂2边长的子集内。
因为我们已经用莫顿编码值对数组{\ttfamily mortonPrims}排过序了，
所以高位值匹配的图元已经位于一段连续数组中。

这里我们将求30位莫顿码中有相同的高12位对应的图元集。
通过线性浏览数组{\ttfamily mortonPrims}来求得群集并
找到这12位中有任何一位发生变化的地方。
这对应了在$2^{12}=4096$个规范网格中对图元聚类，
每维有$2^4=16$个格子。
实践中，许多网格是空的，
尽管这里我们仍然希望求得许多独立的群集。
\begin{lstlisting}
`\initcode{Find intervals of primitives for each treelet}{=}`
std::vector<`\refvar{LBVHTreelet}{}`> treeletsToBuild;
for (int start = 0, end = 1; end <= (int)mortonPrims.size(); ++end) {
    uint32_t mask = 0b00111111111111000000000000000000;
    if (end == (int)mortonPrims.size() ||
        ((mortonPrims[start].`\refvar{mortonCode}{}` & mask) !=
         (mortonPrims[end].`\refvar{mortonCode}{}` & mask))) {
        `\refcode{Add entry to treeletsToBuild for this treelet}{}`
        start = end;
    }
}
\end{lstlisting}

当为一个小树求得一个图元群集后，就立即为它分配\refvar{BVHBuildNode}{}
（回想一个BVH中的节点数量不超过叶子节点数量的两倍，而后者又不超过图元数量）。
在现在的串行执行阶段中预分配这些内存比在LBVH的并行构建中分配更简单。

这里的一个重要细节是传入\refvar[MemoryArena:Alloc2]{MemoryArena::Alloc}{()}的{\ttfamily false}值；
它表示不要执行正在分配的底层对象的构造函数。
令人惊讶的是，运行\refvar{BVHBuildNode}{}构造函数会引入很大开销
并明显降低构建HLBVH时的整体性能。
因为在后面的代码中\refvar{BVHBuildNode}{}的所有成员都会初始化，
所以无论如何这里都没必要用构造函数执行初始化。

\begin{lstlisting}
`\initcode{Add entry to treeletsToBuild for this treelet}{=}`
int nPrimitives = end - start;
int maxBVHNodes = 2 * nPrimitives - 1;
`\refvar{BVHBuildNode}{}` *nodes = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{BVHBuildNode}{}`>(maxBVHNodes, false);
treeletsToBuild.push_back({start, nPrimitives, nodes});
\end{lstlisting}

一旦每个小树的图元都定好了，我们就可以并行地为它们创建LBVH了。
当构建完成后，每个\refvar{LBVHTreelet}{}的指针\refvar{buildNodes}{}会指向相应LBVH的根。

工作线程在构建LBVH时有两个地方必须相互配合。
第一，需要计算所有LBVH中的节点总数并通过传入\refvar{HLBVHBuild}{()}的
指针{\ttfamily totalNode}返回。
第二，当为LBVH创建叶子节点时，
需要数组{\ttfamily orderedPrims}的连续一段来
记录叶子节点中图元的索引。
我们的实现为两者都使用了原子变量——
{\ttfamily atomicTotal}跟踪节点数目，
{\ttfamily orderedPrimsOffset}跟踪{\ttfamily orderedPrims}下一有效项的索引。
\begin{lstlisting}
`\initcode{Create LBVHs for treelets in parallel}{=}`
std::atomic<int> atomicTotal(0), orderedPrimsOffset(0);
orderedPrims.resize(primitives.size());
`\refvar{ParallelFor}{}`(
    [&](int i) {
        `\refcode{Generate ith LBVH treelet}{}`
    }, treeletsToBuild.size());
*totalNodes = atomicTotal;
\end{lstlisting}

构建小树的工作由\refvar{emitLBVH}{()}执行，
它取用形心位于某空间区域内的图元并不断用划分平面
沿着三轴之一上的区域中心将当前空间区域划分为两半。

注意到\refvar{emitLBVH}{()}没有用
指向原子变量{\ttfamily atomicTotal}的指针来计数创建的节点，
而是更新一个非原子局部变量。
然后当每棵小树建成时这里的代码片只对每棵小树更新一次{\ttfamily atomicTotal}。
该方法比让工作线程在其执行过程中频繁修改{\ttfamily atomicTotal}具有明显更好的性能
（见附录\refsub{内存连续模型与性能}关于多核内存连续模型开销的讨论）。
\begin{lstlisting}
`\initcode{Generate ith LBVH treelet}{=}`
int nodesCreated = 0;
const int firstBitIndex = 29 - 12;
`\refvar{LBVHTreelet}{}` &tr = treeletsToBuild[i];
tr.`\refvar{buildNodes}{}` = 
    `\refvar{emitLBVH}{}`(tr.`\refvar{buildNodes}{}`, primitiveInfo, &mortonPrims[tr.`\refvar{startIndex}{}`],
             tr.`\refvar[LBVHTreelet:nPrimitives]{nPrimitives}{}`, &nodesCreated, orderedPrims,
             &orderedPrimsOffset, firstBitIndex);
atomicTotal += nodesCreated;
\end{lstlisting}

幸好有莫顿编码，当前空间区域不需要在\refvar{emitLBVH}{()}中显式表示：
传入的有序{\ttfamily mortonPrims}有一些匹配的高位，反过来对应了一个空间框。
对于莫顿码中剩下的每一位，该函数尝试沿着对应于数位{\ttfamily bitIndex}的平面来划分图元
（回想\reffig{4.8}(d)），然后再递归地调用自己。
尝试用来划分的下一位索引被作为该函数的最后一个参数传入：它最初为$29-12$，
因为29是从零计起的第30位索引，而我们之前用了高12位莫顿码值来聚类图元；
所以，我们知道那些数位都一定匹配该群集。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
`\refvar{BVHBuildNode}{}` *`\refvar{BVHAccel}{}`::`\initvar{emitLBVH}{}`(`\refvar{BVHBuildNode}{}` *&buildNodes,
        const std::vector<`\refvar{BVHPrimitiveInfo}{}`> &primitiveInfo,
        `\refvar{MortonPrimitive}{}` *mortonPrims, int nPrimitives, int *totalNodes,
        std::vector<std::shared_ptr<`\refvar{Primitive}{}`>> &orderedPrims,
        std::atomic<int> *orderedPrimsOffset, int bitIndex) const {
    if (bitIndex == -1 || nPrimitives < maxPrimsInNode) {
        `\refcode{Create and return leaf node of LBVH treelet}{}`
    } else {
        int mask = 1 << bitIndex;
        `\refcode{Advance to next subtree level if there's no LBVH split for this bit}{}`
        `\refcode{Find LBVH split point for this dimension}{}`
        `\refcode{Create and return interior LBVH node}{}`
    }
}
\end{lstlisting}

在\refvar{emitLBVH}{()}用最后低位划分完图元后，
不可能再有更多划分了，就创建一个叶子节点。
或者它也可以在只有很少的图元时就停止并创建叶子节点。

回想{\ttfamily orderedPrimsOffset}是数组{\ttfamily orderedPrims}中
下一有效元素的偏移量。
这里，对{\ttfamily fetch\_add()}的调用原子地将{\ttfamily nPrimitives}的值加到\newline
{\ttfamily orderedPrimsOffset}上并返回相加前它的旧值。
因为这些计算是原子的，多个LBVH构建线程可以
同时分割数组{\ttfamily orderedPrims}中的空间且没有数据竞争。
有了数组中的空间，叶子的构建和之前\refcode{Create leaf BVHBuildNode}{}中实现的方法一样。
\begin{lstlisting}
`\initcode{Create and return leaf node of LBVH treelet}{=}`
(*totalNodes)++;
`\refvar{BVHBuildNode}{}` *node = buildNodes++;
`\refvar{Bounds3f}{}` bounds;
int firstPrimOffset = orderedPrimsOffset->fetch_add(nPrimitives);
for (int i = 0; i < nPrimitives; ++i) {
    int primitiveIndex = mortonPrims[i].`\refvar{primitiveIndex}{}`;
    orderedPrims[firstPrimOffset + i] = primitives[primitiveIndex];
    bounds = `\refvar[Union2]{Union}{}`(bounds, primitiveInfo[primitiveIndex].`\refvar[BVHPrimitiveInfo::bounds]{bounds}{}`);
}
node->`\refvar[BVHBuildNode::InitLeaf]{InitLeaf}{}`(firstPrimOffset, nPrimitives, bounds);
return node;
\end{lstlisting}

可能有所有图元都位于划分平面同一侧的情况；因为图元按其莫顿索引排序，
可以通过看该范围内第一个和最后一个图元对于该平面是否有相同的数位来高效检测该情况。
这种情况下，\refvar{emitLBVH}{()}行进到下一位而不会无用地创建一个节点。
\begin{lstlisting}
`\initcode{Advance to next subtree level if there's no LBVH split for this bit}{=}`
if ((mortonPrims[0].`\refvar{mortonCode}{}` & mask) ==
    (mortonPrims[nPrimitives - 1].`\refvar{mortonCode}{}` & mask))
    return `\refvar{emitLBVH}{}`(buildNodes, primitiveInfo, mortonPrims, nPrimitives,
                    totalNodes, orderedPrims, orderedPrimsOffset,
                    bitIndex - 1);
\end{lstlisting}

如果划分平面两侧都有图元，则二分搜索会高效地找到
当前图元集中第{\ttfamily bitIndex}位从0变为1的划分点。
\begin{lstlisting}
`\initcode{Find LBVH split point for this dimension}{=}`
int searchStart = 0, searchEnd = nPrimitives - 1;
while (searchStart + 1 != searchEnd) {
    int mid = (searchStart + searchEnd) / 2;
    if ((mortonPrims[searchStart].`\refvar{mortonCode}{}` & mask) ==
        (mortonPrims[mid].`\refvar{mortonCode}{}` & mask))
        searchStart = mid;
    else
        searchEnd = mid;
}
int splitOffset = searchEnd;
\end{lstlisting}

有了划分偏移量，该方法现在可以声明一个节点用作内部节点
并为划出的两个图元集递归地构建LBVH了。
注意到莫顿编码还带来了一个方便：
不需要为了划分而复制或记录数组{\ttfamily mortonPrims}中的项：
因为它们都按莫顿码值排序了且从高到低处理数位，
两部分图元已经在划分平面的正确一侧。
\begin{lstlisting}
`\initcode{Create and return interior LBVH node}{=}`
(*totalNodes)++;
`\refvar{BVHBuildNode}{}` *node = buildNodes++;
`\refvar{BVHBuildNode}{}` *lbvh[2] = {
    `\refvar{emitLBVH}{}`(buildNodes, primitiveInfo, mortonPrims, splitOffset,
             totalNodes, orderedPrims, orderedPrimsOffset, bitIndex - 1),
    `\refvar{emitLBVH}{}`(buildNodes, primitiveInfo, &mortonPrims[splitOffset],
             nPrimitives - splitOffset, totalNodes, orderedPrims,
             orderedPrimsOffset, bitIndex - 1)
};
int axis = bitIndex % 3;
node->`\refvar[BVHBuildNode::InitInterior]{InitInterior}{}`(axis, lbvh[0], lbvh[1]);
return node;
\end{lstlisting}

一旦创建好所有LBVH小树，
\refvar{buildUpperSAH}{()}就为所有小树创建一个BVH。
因为它们通常只有几十个或几百个（无论如何不超过4096），
该步骤花的时间很少。
\begin{lstlisting}
`\initcode{Create and return SAH BVH from LBVH treelets}{=}`
std::vector<`\refvar{BVHBuildNode}{}` *> finishedTreelets;
for (`\refvar{LBVHTreelet}{}` &treelet : treeletsToBuild)
    finishedTreelets.push_back(treelet.`\refvar{buildNodes}{}`);
return `\refvar{buildUpperSAH}{}`(arena, finishedTreelets, 0,
                     finishedTreelets.size(), totalNodes);
\end{lstlisting}

这里不介绍该方法的实现，
因为它和完全基于SAH的BVH构建遵循相同的方法，
只不过是在小树根节点上而不是在场景图元上进行。
\begin{lstlisting}
`\initcode{BVHAccel Private Methods}{=}`
`\refvar{BVHBuildNode}{}` *`\initvar{buildUpperSAH}{}`(`\refvar{MemoryArena}{}` &arena,
    std::vector<`\refvar{BVHBuildNode}{}` *> &treeletRoots, int start, int end,
    int *totalNodes) const;
\end{lstlisting}

\subsection{为遍历而压实的BVH}\label{sub:为遍历而压实的BVH}
一旦建好BVH树，最后一步就是将其转换为紧凑的\sidenote{译者注：原文compact。}表达——
这样做能提升缓存、内存以及整个系统的性能。
最后的BVH存于内存中的一个线性数组内。
原始树的节点按\keyindex{深度优先}{depth-first}{}顺序排布，
即意味着在内存中每个内部节点的第一个孩子会立刻排在该节点之后。
这种情况下，只需要显式保存每个内部节点第二个孩子的偏移量。
见\reffig{4.13}关于树的拓扑与内存中节点顺序之间关系的图示。
\begin{figure}[htbp]
    \centering\input{Pictures/chap04/BVHlinearization.tex}
    \caption{BVH在内存中的线性排布。BVH的节点（左）按深度优先顺序（右）存储于内存中。
        因此，对于该树的任意中间节点（例如该例中的A和B），
        第一个孩子可在内存中父节点之后立刻找到。
        第二个孩子则通过偏移指针找到，这里用带箭头的线表示。
        树的叶子结点（D、E和C）没有孩子。}
    \label{fig:4.13}
\end{figure}

结构体\refvar{LinearBVHNode}{}保存遍历BVH所需的信息。
除了每个节点的边界框，它还为每个叶子节点保存偏移量和该节点内的图元数量。
对于内部节点，它保存了第二个孩子的偏移量以及构建层次时
是沿哪个坐标轴划分图元的；
这些信息用于下面的遍历例程以沿着光线按从前往后的顺序访问节点。
\begin{lstlisting}
`\refcode{BVHAccel Local Declarations}{+=}\lastcode{BVHAccelLocalDeclarations}`
struct `\initvar{LinearBVHNode}{}` {
    `\refvar{Bounds3f}{}` `\initvar[LinearBVHNode::bounds]{bounds}{}`;
    union {
        int `\initvar{primitivesOffset}{}`;    // leaf
        int `\initvar{secondChildOffset}{}`;   // interior
    };
    uint16_t `\initvar[LinearBVHNode::nPrimitives]{nPrimitives}{}`;  // 0 -> interior node
    uint8_t `\initvar[LinearBVHNode::axis]{axis}{}`;          // interior node: xyz
    uint8_t `\initvar[LinearBVHNode::pad]{pad}{}`[1];        // ensure 32 byte total size
};
\end{lstlisting}

该结构体被填充了以保证是32字节大小。
这样做保证了如果分配节点时第一个节点是对齐\keyindex{缓存行}{cache line}{}的，
则后续节点不会跨越缓存行
（只要缓存行大小至少为32字节，即现代CPU架构的情况）。

建好的树被方法\refvar{flattenBVHTree}{()}变换为\refvar{LinearBVHNode}{}表示，
它执行深度优先遍历并在内存中按线性顺序存储节点。
\begin{lstlisting}
`\initcode{Compute representation of depth-first traversal of BVH tree}{=}`
nodes = AllocAligned<`\refvar{LinearBVHNode}{}`>(totalNodes);
int offset = 0;
`\refvar{flattenBVHTree}{}`(root, &offset);
\end{lstlisting}

指向\refvar{LinearBVHNode}{}数组的指针保存为\refvar{BVHAccel}{}的一个成员变量，
所以它可以在\refvar{BVHAccel}{}的析构函数中释放。
\begin{lstlisting}
`\refcode{BVHAccel Private Data}{+=}\lastcode{BVHAccelPrivateData}`
`\refvar{LinearBVHNode}{}` *`\initvar[BVHAccel::nodes]{nodes}{}` = nullptr;
\end{lstlisting}

将树展平为线性表示很简单；
参数{\ttfamily *offset}跟踪当前在数组\refvar{BVHAccel::nodes}{}
中的偏移量。注意在递归调用处理其孩子之前
（如果该节点是内部节点）要把当前节点添加到该数组中。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastnext{BVHAccelMethodDefinitions}`
int `\refvar{BVHAccel}{}`::`\initvar{flattenBVHTree}{}`(`\refvar{BVHBuildNode}{}` *node, int *offset) {
    `\refvar{LinearBVHNode}{}` *linearNode = &`\refvar[BVHAccel::nodes]{nodes}{}`[*offset];
    linearNode->`\refvar[LinearBVHNode::bounds]{bounds}{}` = node->`\refvar[BVHBuildNode::bounds]{bounds}{}`;
    int myOffset = (*offset)++;
    if (node->`\refvar[BVHBuildNode:nPrimitives]{nPrimitives}{}` > 0) {
        linearNode->`\refvar{primitivesOffset}{}` = node->`\refvar{firstPrimOffset}{}`;
        linearNode->`\refvar[LinearBVHNode::nPrimitives]{nPrimitives}{}` = node->`\refvar[BVHBuildNode:nPrimitives]{nPrimitives}{}`;
    } else {
        `\refcode{Create interior flattened BVH node}{}`
    }
    return myOffset;
}
\end{lstlisting}

在内部节点时，递归调用会展平两棵子树。
第一棵如愿在数组中当前节点之后立刻结束，
而其递归调用\refvar{flattenBVHTree}{()}返回的第二棵偏移量
则保存在该节点的成员\refvar{secondChildOffset}{}中。
\begin{lstlisting}
`\initcode{Create interior flattened BVH node}{=}`
linearNode->`\refvar[LinearBVHNode::axis]{axis}{}` = node->`\refvar[BVHBuildNode::splitAxis]{splitAxis}{}`;
linearNode->`\refvar[LinearBVHNode::nPrimitives]{nPrimitives}{}` = 0;
`\refvar{flattenBVHTree}{}`(node->`\refvar[BVHBuildNode::children]{children}{}`[0], offset);
linearNode->`\refvar{secondChildOffset}{}` =
    `\refvar{flattenBVHTree}{}`(node->`\refvar[BVHBuildNode::children]{children}{}`[1], offset);
\end{lstlisting}

\subsection{遍历}\label{sub:遍历}
BVH的遍历代码非常简单——没有递归调用，只有少量数据用来维护当前遍历的状态。
方法\refvar[BVHAccel::Intersect]{Intersect}{()}从
预先计算一些与将要反复用到的光线相关的值开始。
\begin{lstlisting}
`\refcode{BVHAccel Method Definitions}{+=}\lastcode{BVHAccelMethodDefinitions}`
bool `\refvar{BVHAccel}{}`::`\initvar[BVHAccel::Intersect]{Intersect}{}`(const `\refvar{Ray}{}` &ray,
        `\refvar{SurfaceInteraction}{}` *isect) const {
    bool hit = false;
    `\refvar{Vector3f}{}` invDir(1 / ray.d.x, 1 / ray.d.y, 1 / ray.d.z);
    int dirIsNeg[3] = { invDir.x < 0, invDir.y < 0, invDir.z < 0 };
    `\refcode{Follow ray through BVH nodes to find primitive intersections}{}`
    return hit;
}
\end{lstlisting}

每当\refvar[BVHAccel::Intersect]{Intersect}{()}中的{\ttfamily while}循环开始一次迭代时，
{\ttfamily currentNodeIndex}保有将要访问的节点在数组\refvar[BVHAccel::nodes]{nodes}{}中的偏移量。
它起始于0值，表示树根。仍需要访问的节点存于数组{\ttfamily nodesToVisit[]}中，即充当一个栈；
{\ttfamily toVisitOffset}存有栈中下一个可弹出元素的偏移量。
\begin{lstlisting}
`\initcode{Follow ray through BVH nodes to find primitive intersections}{=}`
int toVisitOffset = 0, currentNodeIndex = 0;
int nodesToVisit[64];
while (true) {
    const `\refvar{LinearBVHNode}{}` *node = &`\refvar[BVHAccel::nodes]{nodes}{}`[currentNodeIndex];
    `\refcode{Check ray against BVH node}{}`
}
\end{lstlisting}

对于每个节点，我们都检查光线是否与节点的边界框相交（或从其内部发射）。
如果是我们就访问该节点，如果它是叶子节点就对其图元做相交测试，
如果是内部节点就处理它的孩子。
如果发现没有相交，就从{\ttfamily nodesToVisit[]}取出下一个将要访问的节点的偏移量
（或者如果栈空了就完成遍历了）。
\begin{lstlisting}
`\initcode{Check ray against BVH node}{=}`
if (node->`\refvar[LinearBVHNode::bounds]{bounds}{}`.`\refvar[Bounds3::IntersectP2]{IntersectP}{}`(ray, invDir, dirIsNeg)) {
    if (node->`\refvar[LinearBVHNode::nPrimitives]{nPrimitives}{}` > 0) {
        `\refcode{Intersect ray with primitives in leaf BVH node}{}`
    } else {
        `\refcode{Put far BVH node on nodesToVisit stack, advance to near node}{}`
    }
} else {
    if (toVisitOffset == 0) break;
    currentNodeIndex = nodesToVisit[--toVisitOffset];
}
\end{lstlisting}

如果当前节点是叶子，则该光线必须和它里面的图元做相交测试。
然后从栈{\ttfamily nodesToVisit}中找到下一个要访问的节点；
即使当前节点求得了交点，也必须访问剩下的节点，
以防万一它们中有一个给出更近的交点。
然而，如果求得一个交点，则该光线的\refvar{tMax}{}值将会更新为该相交距离；
这样可以更高效地丢弃剩下的节点中任何比该距离更远的部分。
\begin{lstlisting}
`\initcode{Intersect ray with primitives in leaf BVH node}{=}`
for (int i = 0; i < node->`\refvar[LinearBVHNode::nPrimitives]{nPrimitives}{}`; ++i)
    if (`\refvar[BVHAccel::primitives]{primitives}{}`[node->`\refvar{primitivesOffset}{}` + i]->`\refvar[Primitive::Intersect]{Intersect}{}`(ray, isect))
        hit = true;
if (toVisitOffset == 0) break;
currentNodeIndex = nodesToVisit[--toVisitOffset];
\end{lstlisting}

对于光线命中的内部节点，需要访问它的两个孩子。
如上所述，万一与光线相交的图元在第一个里面，
则访问光线穿过的第一个孩子再访问第二个是可取的，
这样光线的\refvar{tMax}{}值就能更新，
进而缩减光线的范围以及与之相交的边界框节点数目。

一个执行从前往后遍历而不会因光线与两个子节点相交
以及比较距离而带来开销的高效方法是使用光线方向向量
在该节点划分图元时所沿的坐标轴上的符号：
如果符号为负，我们应该先访问第二个孩子再访问第一个孩子，
因为进入第二棵子树的图元在划分点的上面一侧
（正号方向则反过来）。
这样做很简单：先要访问的节点的偏移量被复制到{\ttfamily currentNodeIndex}，
另一个节点的偏移量被加到栈{\ttfamily nodesToVisit}中
（回想因为内存中节点按深度优先排列，第一个孩子正好在当前节点之后）。
\begin{lstlisting}
`\initcode{Put far BVH node on nodesToVisit stack, advance to near node}{=}`
if (dirIsNeg[node->`\refvar[LinearBVHNode::axis]{axis}{}`]) {
   nodesToVisit[toVisitOffset++] = currentNodeIndex + 1;
   currentNodeIndex = node->`\refvar{secondChildOffset}{}`;
} else {
   nodesToVisit[toVisitOffset++] = node->`\refvar{secondChildOffset}{}`;
   currentNodeIndex = currentNodeIndex + 1;
}
\end{lstlisting}

方法{\initvar{BVHAccel::IntersectP}{()}}本质上和常规相交方法一样，有两处区别是，它调用了\refvar{Primitive}{}的
方法\refvar[Primitive::IntersectP]{IntersectP}{()}而不是\refvar[Primitive::Intersect]{Intersect}{()}，
以及当找到任何交点时就立刻停止遍历。
