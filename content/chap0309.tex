\section{控制舍入误差}\label{sec:控制舍入误差}

\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

到目前为止，我们都是根据基于实数的理想化算术运算
纯粹地讨论光线-形状相交算法。该方法已经让我们走得很远了，
尽管有个重要事实是计算机只能表示有限的数量，
因此它实际上不能表示所有实数。
计算机用浮点数代替实数，它有固定的存储要求。
然而，因为结果可能无法在特定量的内存中表示，
每执行一次浮点运算就可能引入误差。

该误差的累积对相交测试的精度有些许影响。
首先，它可能造成完全错过有效的相交——
例如，一个精确值是正数的相交处$t$值算成了负的。
而且，算得的光线-形状交点可能在形状实际曲面的上面或下面。
这导致一个问题：当从算得的交点开始为阴影射线和反射光线追踪新光线时，
若射线端点在实际曲面之下，我们可能求得一次与曲面错误的再相交。
反之，若端点在曲面上面离得太远，阴影和反射可能会脱钩（见\reffig{3.39}）。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectioncases.tex}
    \caption{可能在图像中造成可见错误的舍入误差问题几何设置。
        左边的入射光线与曲面相交。在左图中，算得的交点（黑圆圈）略低于曲面
        且阴影射线端点过低的“epsilon”偏移可能导致错误的自相交，
        因为阴影射线端点（白圆圈）仍在曲面之下；因此错误地认定光源被遮挡了。
        右图中，太高的“epsilon”导致错过了有效相交，
        因为射线端点通过了遮挡面。}
    \label{fig:3.39}
\end{figure}

在光线追踪中解决该问题的典型实践是将生成的射线偏移固定的“射线epsilon”值
\sidenote{译者注：epsilon即希腊字母$\epsilon$。}，
忽略沿射线$\bm p+t\bm d$比某个$t_{\min}$还近的任何相交。
\reffig{3.40}展示了为什么该方法需要很高的$t_{\min}$值才能高效工作：
如果生成的射线相对于曲面非常倾斜，
则在离射线很远处可能会发生错误的射线相交。
不幸的是，大的$t_{\min}$值会造成射线端点相对远离原始交点，
这又反过来造成错过附近的有效相交，导致阴影和反射丢失细节。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Selfintersectionobliqueray.tex}
    \caption{如果算得的交点（实心圆）低于曲面且生成的射线是斜的，
        在与射线端点有一定距离的地方可能会发生错误的再相交（空心圆）。
        如果用沿射线的最小$t$值消除附近的相交，
        需要相对大的$t_{\min}$才能处理好倾斜射线。}
    \label{fig:3.40}
\end{figure}

本节中，我们将介绍浮点算术基本思想并描述分析浮点计算误差的技术。
然后我们将这些方法用于本章之前介绍的光线-形状算法
并展示怎样计算带有有界误差的光线交点。
这将允许我们保守地定位射线端点，这样就永远不会求得错误的自相交，
而又保留了与实际交点极其接近的射线端点使得错误脱靶被最小化。
反过来也不需要额外的“射线epsilon”值。

\subsection{浮点算术}\label{sub:浮点算术}
计算必须在容纳于有限量内存的数字的有限表示上执行；
计算机上无法表示实数的无限集合。
一种这样的有限表示是定点，例如给定一个16位整数，
有人可能通过除以256将其映射为正实数。
这允许我们表示值之间具有相等间距$\displaystyle\frac{1}{256}$的
范围$\displaystyle\left[0,\frac{65535}{256}\right]=\left[0,255+\frac{255}{256}\right]$。
\keyindex{定点数}{fixed-point number}{}可以用整数算术运算高效实现
（该特性使其在早期不支持浮点计算的个人计算机上很流行），
但是它们受制于许多缺点：其中，它们能表示的最大数字是受限的，
且不能精确表示非常小的接近于零的数。

计算机上实数的另一种表示是\keyindex{浮点数}{floating-point number}{}。
它用\keyindex{符号}{sign}{}、\keyindex{有效数字}{significand}{}\footnote{单词“\protect\keyindex{尾数}{mantissa}{}”
    常用来代替“有效数字”，但浮点纯粹主义者注意到“尾数”在对数上下文中
    有不同含义而因此更偏爱“有效数字”。这里我们遵循该用法。}和\keyindex{指数}{exponent}{}表示数字：
本质上和\keyindex{科学计数法}{scientific notation}{}相同但用固定数量的数字表示有效数字和指数。
（下文中，我们将只讨论以2为底的数字。）
这种表示能够用固定数量的存储对极大范围的数字进行表示和执行计算。

用浮点算术的程序员通常知道浮点是不精确的；
有时这种看法导致了浮点算术是不可预测的观念。
本节中我们将看到浮点算术有精心设计的基础反而
能计算特定计算中引入误差的保守边界。
对于光线追踪计算，该误差常意外地小。

现代CPU和GPU几乎都基于电气与电子工程师协会
\sidenote{译者注：即Institute of Electrical and Electronics Engineers (IEEE)，
    是电气工程与电子工程以及相关学科的专业协会，成立于1963年1月，总部在美国纽约。
    其范围已经扩展到电气、电子、通信、计算机工程、计算机科学与信息技术等诸多领域，
    是世界上最大的技术专业组织。}
颁布的标准\parencite*{10.1109/IEEESTD.1985.82928,10.1109/IEEESTD.2008.4610935}实现浮点算术模型。
（今后我们说的浮点特指IEEE 754规定的32位浮点数。）
IEEE 754技术标准规定了内存中浮点数的格式以及
精度和浮点计算舍入的特定规则；
正是这些规则使得能对给定浮点值中出现的误差进行严格推导。

\subsubsection*{浮点表示}
IEEE标准规定32位浮点用1位符号、8位指数和23位有效数字表示。
用了8位的指数$e$范围为从0到255；
实际用的指数$e_{\mathrm{b}}$是通过偏置$e$算得的：
\begin{align*}
    e_{\mathrm{b}}=e-127\, .
\end{align*}

当存储\keyindex{规范化的}{normalized}{}浮点值时有效数字实际有24位精度。
当有效数字和指数表示规范化的数字时，有效数字中没有前导零。
在\keyindex{二进制}{binary}{}中，这意味着有效数字开头的数字必须是一；
反过来，没必要显式存储该值。
因此，隐式前导的1位和编码有效数字小数部分的23位给出了总共24位的精度。

给定符号$s=\pm 1$、有效数字$m$和指数$e$，相应的浮点值为
\begin{align*}
    s\times 1.m\times2^{e-127}\, .
\end{align*}

例如，浮点数6.5可以通过规范化的有效数字写作$1.101_2\times2^2$，
其中下标2表示以2为底的值\sidenote{译者注：即二进制。}
（如果非整数的二进制数不够直观，可以注意
小数点右边第一个数表示$2^{-1}$，以此类推）。
因此，我们有
\begin{align*}
    (1\times2^0+1\times2^{-1}+0\times2^{-2}+1\times2^{-3})\times2^2=1.625\times2^2=6.5\, .
\end{align*}
$e_{\mathrm{b}}=2$，所以$e=129=10000001_2$且$m=10100000000000000000000_2$。

浮点在内存中的布局是符号位在32位值的最高位
（负号用一位编码），然后是指数和有效数字。
因此，对于值6.5其内存中的二进制表示是
\begin{align*}
    0\ 10000001\ 10100000000000000000000=40\mathrm{d}00000_{16}\, .
\end{align*}

同样，浮点值1.0有$m=0\ldots0_2$和$e_{\mathrm{b}}=0$，所以$e=127=01111111_2$，它的二进制表示为
\begin{align*}
    0\ 01111111\ 00000000000000000000000=3\mathrm{f}800000_{16}\, .
\end{align*}

该\keyindex{十六进制}{hexadecimal}{}值值得记住，因为调试时它常出现于内存转储。

该表示隐含了整个范围内两个相邻的二的幂次之间
可表示的浮点数之间的间隔是均匀的（它对应于有效数字位增一）。
在范围$[2^e,2^{e+1})$内，间隔为
\begin{align}\label{eq:3.6}
    2^{e-23}\, .
\end{align}
因此对1和2之间的浮点数，$e=0$，
浮点值间的间隔为$2^{-23}\approx1.19209\times10^{-7}$。
该间隔也称为\keyindex{最后一位上的单位值}{unit in last place}{}(ulp)\sidenote{译者注：也叫“最小精度单位”。}的大小；
注意一个ulp的大小由相应浮点值决定——更大的数的ulp比更小的数的ulp相对更大。

按我们目前描述的表示是不可能恰好将零表示为浮点数的。
这事显然不可接受，所以最小指数$e=0$，
或说$e_{\mathrm{b}}=-127$，被留出来特殊对待。
对于该指数，浮点值解释为有效数字中没有隐式前导一位，
这意味全零位的有效数字会得到
\begin{align*}
    s\times0.0\ldots0_2\times2^{-127}=0\, .
\end{align*}

去掉有效数字前导一位也能表示\keyindex{非规范化的}{denormalized}{}数：
如果总是出现前导一\sidenote{译者注：我完善了该式。}，则最小的32位浮点是
\begin{align*}
    1.{\underbrace{0\ldots0}_{\text{23个0}}}\ _2\times2^{-127}\approx5.8774718\times10^{-39}\, .
\end{align*}
没有前导一位\sidenote{译者注：我完善了该式；如果你难以理解为何指数变成了$2^{-126}$，
也可以等价地看作$\underbrace{0.0\ldots0}_{22\text{个}0}1_2\times2^{-127}=2^{-22}\times2^{-127}$。}，最小值是
\begin{align*}
    0.\underbrace{0\ldots0}_{\text{22个0}}1_2\times2^{-126}=2^{-23}\times2^{-126}\approx1.4012985\times10^{-45}\, .
\end{align*}

有了表示这些小值的能力可以避免需要将非常小的数舍入为零。

注意该表示同时有“正”和“负”零值。
该细节对程序员大多是透明的。
例如，标准保证了比较{\ttfamily -0.0 == 0.0}为真，
即使这两值在内存中的表示不同。

最大指数，$e=255$，也保留作特殊对待。
因此，可以表示的最大规范化浮点值有$e=254$（或$e_{\mathrm{b}}=127$）且约为\sidenote{译者注：我完善了该式。}
\begin{align*}
    1.{\underbrace{1\ldots1}_{\text{23个1}}}\ _2\times2^{127}=(2-2^{-23})\times2^{127}\approx3.402823\times10^{38}\, .
\end{align*}

对于$e=255$，若有效数字位全是零，则该值依据符号位对应正或负无穷。
例如，在浮点中执行像1/0的计算会得到无穷值。
对无穷的算术运算得到无穷。
比较时，正无穷大于任何非无穷值，负无穷类似。

常数\refvar{MaxFloat}{}和\refvar{Infinity}{}分别初始化为可表示的最大和“无穷”浮点值。
我们令其可在单独的常数中获取，这样使用这些值的代码
就不需要用唠叨的C++标准库调用来获取它们的值了。
\begin{lstlisting}
`\initcode{Global Constants}{=}\initnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MaxFloat}{}` = std::numeric_limits<`\refvar{Float}{}`>::max();
static constexpr `\refvar{Float}{}` `\initvar{Infinity}{}` = std::numeric_limits<`\refvar{Float}{}`>::infinity();
\end{lstlisting}

对于$e=255$，非零有效数字位对应
特殊的NaN值\sidenote{译者注：原文误写为$e_b=255$，已修正。}，
它由诸如取负数平方根或尝试计算0/0的运算得到。
NaN随计算传播：\keyindex{运算对象}{operand}{}之一
为NaN本身的任何算术运算总是返回NaN。
因此，如果NaN出现于一长串计算中，
我们就知道该方式中的某处出错了。
在调试构建中，pbrt有许多\refvar{Assert}{()}语句检查NaN值，
因为我们几乎从不希望它们出现在事件的常规过程中。
任何与NaN值的比较返回假；
因此检查{\ttfamily !(x == x)}用来检查值是否不是数字
\footnote{这是编译器不得对包含浮点值的表达式执行
看似明显且安全的代数简化的少数几个地方之一——
这个特别的比较不得简化为{\ttfamily false}。
启用编译器的“快速数学”或“执行不安全的数学优化”标志
可能会允许执行这些优化。但是错误行为可能引入pbrt中。}。
为了清楚起见，我们用C++标准库函数{\ttfamily std::isnan()}来检查NaN值。

\subsubsection*{实用例程}
对于某些底层运算，能将浮点值解释为其组成位以及将表示浮点值的数位
转换为实际的{\ttfamily float}或{\ttfamily double}很有用。

一个自然的方法是取指向要转换的值的指针并将其强制转换为另一类型：
{\ttfamily\newline\noindent
float f = ...;\newline\noindent
uint32\_t bits = *((uint32\_t *)\&f);\newline
}
然而，现代版本的C++规定将一种{\ttfamily float}指针强制转换为
不同类型{\ttfamily uint32\_t}是非法的
（该限制允许编译器在分析两个指针是否可能指向
同一内存位置时进行更激进的优化，禁止在寄存器中保存值）。

另一常见方法是对两类元素使用{\ttfamily union}，赋予一种类型并按另一种读取：
{\ttfamily\newline\noindent
union FloatBits \{\newline\noindent
\indent float f;\newline\noindent
\indent uint32\_t ui;\newline\noindent
\};\newline\noindent
FloatBits fb;\newline\noindent
fb.f = ...;\newline\noindent
uint32\_t bits = fb.ui;
}

这也是非法的：C++标准说从{\ttfamily union}读取和最后一次赋值时不同的元素是未定义行为。

可以用{\ttfamily memcpy()}将指向源类型的指针复制到指向目标类型的指针来正确执行这些转换。
\begin{lstlisting}
`\initcode{Global Inline Functions}{=}\initnext{GlobalInlineFunctions}`
inline uint32_t `\initvar{FloatToBits}{}`(float f) {
    uint32_t ui;
    memcpy(&ui, &f, sizeof(float));
    return ui;
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline float `\initvar{BitsToFloat}{}`(uint32_t ui) {
    float f;
    memcpy(&f, &ui, sizeof(uint32_t));
    return f;
}
\end{lstlisting}

尽管调用函数{\ttfamily memcpy()}以避免这些问题可能看起来太昂贵了，
但实际中好的编译器会将其变为无操作而只是将寄存器或内存中的内容重新解释为另一类型
（pbrt中还有这些函数在{\ttfamily double}和{\ttfamily uint64\_t}之间
转换的类似版本，所以这里就不介绍了）。

这些转换可用于实现函数即把浮点值向上或向下调整到相邻更大或更小的可表示浮点值
\footnote{这些函数等价于{\ttfamily std::nextafter(v, Infinity)}和{\ttfamily std::nextafter(v, -Infinity)}但更加高效，
因为它们不负责处理NaN值或浮点信号异常。}。
它们对我们接下来的代码中需要的某些保守的舍入操作很有用。
多亏浮点在内存中表示的特殊性，这些操作很高效。
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline float `\initvar{NextFloatUp}{}`(float v) {
    `\refcode{Handle infinity and negative zero for NextFloatUp()}{}`
    `\refcode{Advance v to next higher float}{}`
}
\end{lstlisting}

有两种重要的特殊情况：如果{\ttfamily v}为正无穷，则该函数就返回没变的{\ttfamily v}。
在继续执行有效数字的代码之前让负零向前跳到正零。
这一步必须显式处理，因为-0.0和0.0的位模式不相邻。
\begin{lstlisting}
`\initcode{Handle infinity and negative zero for NextFloatUp()}{=}`
if (std::isinf(v) && v > 0.)
    return v;
if (v == -0.f)
    v = 0.f;
\end{lstlisting}

概念上，给定一浮点值，我们想对有效数字增加一，
如果结果\keyindex{溢出}{overflow}{}，
则有效数字重置为零且指数增加一。
意外的是对浮点在内存中的整数表示加一实现了这点：
因为指数在有效数字之上的高位，所以如果有效数字全是一，
则有效数字低位加一会将一一路带到指数去，
否则就在当前指数下推进到相邻更大的有效数字。
还要注意当增加最大可表示的有限浮点值数位表示时，
会得到正的浮点无穷数位模式。

对于负值，从数位表示减一类似地推进到相邻值。
\begin{lstlisting}
`\initcode{Advance v to next higher float}{=}`
uint32_t ui = `\refvar{FloatToBits}{}`(v);
if (v >= 0) ++ui;
else        --ui;
return `\refvar{BitsToFloat}{}`(ui);
\end{lstlisting}

这里没有介绍函数{\initvar{NextFloatDown}{()}}了，
它遵循相同的逻辑但高效地取反。
pbrt也提供了这些函数的{\ttfamily double}版本。

\subsubsection*{算术运算}
IEEE 754提供了关于浮点算术的重要保证：
具体而言，它保证了加法、减法、乘法、除法和平方根
在相同输入下给出相同结果且这些结果的浮点数最接近于
在无限精度算术下执行底层计算的结果
\footnote{IEEE浮点允许用户选一种数字舍入模式，
    但我们这里假设用默认的——舍入到最近的偶数。}。
值得注意的是这在有限精度数字计算机上是完全可能的；
IEEE 754的成就之一是证明了这种级别的精度是可能的且
能在硬件上很高效地实现。

用圆圈运算符表示浮点算术运算符，用sqrt表示浮点平方根，
这些精度保证可以写作：
\begin{align}
    a\oplus b        & =\mathrm{round}(a+b)\, ,\nonumber      \\
    a\ominus b       & =\mathrm{round}(a-b)\, ,\nonumber      \\
    a\otimes b       & =\mathrm{round}(a*b)\, ,\label{eq:3.7} \\
    a\oslash b       & =\mathrm{round}(a/b)\, ,\nonumber      \\
    \mathrm{sqrt}(a) & =\mathrm{round}(\sqrt{a})\, ,\nonumber
\end{align}
其中$\mathrm{round}(x)$表示将实数舍入到最接近的浮点值的结果。

舍入误差的界可以表示为实数区间：例如
对于加法，我们可以说舍入的结果在与某个$\epsilon$有关的区间内
\begin{align}
    a\oplus b & =\mathrm{round}(a+b)\in(a+b)(1\pm\epsilon)\nonumber \\
              & =[(a+b)(1-\epsilon),(a+b)(1+\epsilon)]\, ,
    \label{eq:3.8}
\end{align}
该舍入引入的误差量不超过在$a+b$处的浮点间隔的一半——
如果它超过浮点间隔的一半，则它会以更小误差舍入到另一个不同的浮点数（\reffig{3.41}）。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/IEEEfloatspacing.tex}
    \caption{IEEE标准规定浮点计算必须实现为假设以无限精度的实数
        执行计算再舍入到最接近的可表示浮点。
        这里，无限精度得到的实数表示为实心点，
        它附近可表示的浮点表示为数轴上的刻度。
        我们可以看到舍入到最近浮点引入的误差$\delta$不超过
        浮点之间间隔的一半。}
    \label{fig:3.41}
\end{figure}

对于32位浮点，我们可以用\refeq{3.6}确定
在$a+b$处的浮点间隔（即该值处的ulp）上界为$(a+b)2^{-23}$，
所以间隔一半的上界为$(a+b)2^{-24}$，所以$|\epsilon|\le2^{-24}$。
该界称为\keyindex{机器$\epsilon$}{machine epsilon}{}
\footnote{不幸的是，C和C++标准用它们自己的特殊方式定义了机器$\epsilon$，
    即数字1之上一个ulp的大小。对于32位浮点，该值为$2^{-23}$，
    是数值分析用的术语机器$\epsilon$的两倍大。}。
对于32位浮点，$\epsilon_{\mathrm{m}}=2^{-24}\approx5.960464\times10^{-8}$。
\begin{lstlisting}
`\refcode{Global Constants}{+=}\lastnext{GlobalConstants}`
static constexpr `\refvar{Float}{}` `\initvar{MachineEpsilon}{}` =
       std::numeric_limits<`\refvar{Float}{}`>::epsilon() * 0.5;
\end{lstlisting}
因此我们有
\begin{align*}
    a\oplus b & =\mathrm{round}(a+b)\in(a+b)(1\pm\epsilon_{\mathrm{m}})\nonumber     \\
              & =[(a+b)(1-\epsilon_{\mathrm{m}}),(a+b)(1+\epsilon_{\mathrm{m}})]\, ,
\end{align*}

类似的关系对其他算术运算符和平方根运算符成立
\footnote{该界假设计算中没有上溢或\protect\keyindex{下溢}{underflow}{}；
    可以很容易处理这些可能的情况\citep[p.56]{doi:10.1137/1.9780898718027}但
    一般对于我们这里的应用并不重要。}。

可以从\refeq{3.7}直接得到许多有用的性质。
对于浮点数$x$，
\begin{itemize}
    \item $1\otimes x=x$。
    \item $x\oslash x=1$。
    \item $x\oplus 0=x$。
    \item $x\ominus x=0$。
    \item $2\otimes x$和$x\oslash 2$是准确的；计算最终结果没有执行舍入。
          更一般地，任何乘以或除以二的幂都得到准确结果（假设没有上溢或下溢）。
    \item $x\oslash 2^i=x\otimes 2^{-i}$对所有整数$i$成立，假设$2^i$不溢出。
\end{itemize}

所有这些性质都是从结果必须是与实际结果最接近的浮点值这一原则推出的；
当结果可以准确表示时，必须算得准确结果。

\subsubsection*{误差传播}
利用IEEE浮点算术的保证，可以开发方法分析并界定给定浮点计算的误差。
关于该话题的更多细节，详见\citet{doi:10.1137/1.9780898718027}的优秀书籍
以及\citet{10.5555/1096474}的早期经典
\sidenote{译者注：笔者将引用换成了1994年新版。}。

在这项工作中有两种有用的误差度量：绝对的和相对的。
如果我们执行某浮点计算并得到舍入的结果$\tilde{a}$，
我们说$\tilde{a}$和以实数进行该计算的结果之间的
差的大小为\keyindex{绝对误差}{absolute error}{}$\delta_{\mathrm{a}}$：
\begin{align*}
    \delta_{\mathrm{a}}=|\tilde{a}-a|\, .
\end{align*}

\keyindex{相对误差}{relative error}{}$\delta_{\mathrm{r}}$是
绝对误差和精确结果的比值：
\begin{align}\label{eq:3.9}
    \delta_{\mathrm{r}}=\left|\frac{\tilde{a}-a}{a}\right|=\left|\frac{\delta_{\mathrm{a}}}{a}\right|\, ,
\end{align}
只要$a\neq0$。利用相对误差定义，
我们可将算得的值$\tilde{a}$写作准确结果$a$的扰动：
\begin{align*}
    \tilde{a}=a\pm\delta_{\mathrm{a}}=a(1\pm\delta_{\mathrm{r}})\, .
\end{align*}

作为这些思想的首个应用，考虑计算四个表示为浮点的数$a,b,c$和$d$的和。
如果我们将该和算为{\ttfamily r = (((a + b) + c) + d)}，\refeq{3.8}给出
\begin{align*}
    (((a\oplus b)\oplus c)\oplus d) & \in((((a+b)(1\pm\epsilon_{\mathrm{m}}))+c)(1\pm\epsilon_{\mathrm{m}})+d)(1\pm\epsilon_{\mathrm{m}}) \\
                                    & =(a+b)(1\pm\epsilon_{\mathrm{m}})^3+c(1\pm\epsilon_{\mathrm{m}})^2+d(1\pm\epsilon_{\mathrm{m}})\, .
\end{align*}
因$\epsilon_{\mathrm{m}}$很小，$\epsilon_{\mathrm{m}}$的高次幂可被额外项$\epsilon_{\mathrm{m}}$限定，
所以我们可将$(1\pm\epsilon_{\mathrm{m}})^n$限为
\begin{align*}
    (1\pm\epsilon_{\mathrm{m}})^n\le1\pm(n+1)\epsilon_{\mathrm{m}}\, .
\end{align*}
（实际情况是，$1\pm n\epsilon_{\mathrm{m}}$几乎界定了这些项，
因为$\epsilon_{\mathrm{m}}$的更高次幂变小得很快，但上面是完全保守的界。）

该界让我们把加法的结果化简为：
\begin{align*}
      & (a+b)(1\pm4\epsilon_{\mathrm{m}})+c(1\pm3\epsilon_{\mathrm{m}})+d(1\pm2\epsilon_{\mathrm{m}})    \\
    = & a+b+c+d+[\pm4\epsilon_{\mathrm{m}}(a+b)\pm3\epsilon_{\mathrm{m}}c\pm2\epsilon_{\mathrm{m}}d]\, .
\end{align*}

方括号内的项给出了绝对误差：其大小限定为
\begin{align}\label{eq:3.10}
    \pm4\epsilon_{\mathrm{m}}|a+b|\pm3\epsilon_{\mathrm{m}}|c|\pm2\epsilon_{\mathrm{m}}|d|\, .
\end{align}

因此，如果我们按上述括号把四个浮点数加在一起，
我们可以确定最后舍入的结果与假设我们
用无限精度实数相加得到的结果之间的差被\refeq{3.10}界定。
给定$a,b,c$和$d$的具体值很容易计算该误差界。

这个结果很有趣；我们看到$a+b$的大小对误差界作相对较大的贡献，
尤其是和$d$相比的时候
（这个结果给出了一种情况，即为什么如果大量浮点数相加时，
将他们从小到大排序一般会给出比任意顺序有更低最终误差的结果）。

这里我们的分析隐含假设编译器会根据定义该和的表达式生成指令。
编译器应遵循给定浮点表达式的形式以避免破坏仔细设计的能最小化舍入误差的计算。
这又有某些用整数表达式时有效的转换不能安全用于浮点计算的情况。

如果我们把表达式改为算术等价的{\ttfamily float r = (a + b) + (c + d)}会怎么样？
相应的浮点计算为
\begin{align*}
    ((a\oplus b)\oplus(c\oplus d))\, .
\end{align*}

如果我们采用运用\refeq{3.8}的相同过程，展开项，
将高次项$(1\pm\epsilon_{\mathrm{m}})^n$转换为$1\pm(n+1)\epsilon_{\mathrm{m}}$，
我们得到绝对误差界为
\begin{align*}
    3\epsilon_{\mathrm{m}}|a+b|+3\epsilon_{\mathrm{m}}|c+d|\, ,
\end{align*}
它在$|a+b|$相对较大时低于第一种算法，但若$|d|$相对较大则可能更高。

这种计算误差的方法称为\keyindex{前向误差分析}{forward error analysis}{}；
给定计算输入，我们可用很机械的过程提供结果误差的保守边界。
结果中推导的界可能夸大了实际误差——
实际中误差项的符号通常是混合的，所以当它们相加时会有抵消
\footnote{一些数值分析员用的经验法则是，因为中间结果误差抵消，
    实际误差的ulp数通常接近于ulp的边界数的平方根。}
\sidenote{译者注：这句脚注看不懂。}。
另一种方法是\keyindex{后向误差分析}{backward error analysis}{}，
把算得结果当做准确的并提供所给结果相同时对输入扰动的界。
当分析数值算法的稳定性时该方法更有用，
但不太适合于推导我们这里关注的几何计算的保守误差界。

用$1\pm(n+1)\epsilon_{\mathrm{m}}$作为$(1\pm\epsilon_{\mathrm{m}})^n$的
保守边界还是有点不满意，因为它仅是加上整个$\epsilon_{\mathrm{m}}$项以
保守地界定各个$\epsilon_{\mathrm{m}}$高次项的和。
\citet[3.1节]{doi:10.1137/1.9780898718027}给出了
一个更紧致界定误差项$1\pm\epsilon_{\mathrm{m}}$之积的方法
\sidenote{译者注：笔者无法阅读到该文献，
    但认为可以利用级数展开和二项式展开证明相应不等式成立。}。
如果我们有$(1\pm\epsilon_{\mathrm{m}})^n$，
则可以证明该值被$1+\theta_n$界定，其中
\begin{align}\label{eq:3.11}
    |\theta_n|\le\frac{n\epsilon_{\mathrm{m}}}{1-n\epsilon_{\mathrm{m}}}\, ,
\end{align}
只要$n\epsilon_{\mathrm{m}}<1$（当然是我们考虑计算的情况）
\sidenote{译者注：更确切说是$0\le n\epsilon_{\mathrm{m}}<1$。}。
注意到对于合理$n$值该表达式的分母会小于一，
所以它只是稍稍增大$n\epsilon_{\mathrm{m}}$以获得保守边界。

我们用$\gamma_n$表示该界：
\begin{align*}
    \gamma_n=\frac{n\epsilon_{\mathrm{m}}}{1-n\epsilon_{\mathrm{m}}}\, .
\end{align*}

计算该值的函数声明为{\ttfamily constexpr}，
这样任何带有编译时常量的调用都会被替换为相应的浮点返回值。
\begin{lstlisting}
`\refcode{Global Inline Functions}{+=}\lastnext{GlobalInlineFunctions}`
inline constexpr `\refvar{Float}{}` `\initvar{gamma}{}`(int n) {
    return (n * `\refvar{MachineEpsilon}{}`) / (1 - n * `\refvar{MachineEpsilon}{}`);
}
\end{lstlisting}

使用$\gamma$符号，四个值之和的误差被界定为
\begin{align*}
    |a+b|\gamma_3+|c|\gamma_2+|d|\gamma_1\, .
\end{align*}

该方法的一个优点是$(1\pm\epsilon_{\mathrm{m}})^n$项的商也可以用$\gamma$函数定界。
给定
\begin{align*}
    \frac{(1\pm\epsilon_{\mathrm{m}})^m}{(1\pm\epsilon_{\mathrm{m}})^n}\, ,
\end{align*}
该区间以$1\pm\gamma_{m+n}$为界
\sidenote{译者注：通分构造函数并利用导数知识可以证明哪怕极端情况下
    也有$\displaystyle\frac{(1+\epsilon_{\mathrm{m}})^m}{(1-\epsilon_{\mathrm{m}})^n}\le1+\gamma_{m+n}$
    与$\displaystyle\frac{(1-\epsilon_{\mathrm{m}})^m}{(1+\epsilon_{\mathrm{m}})^n}\ge1-\gamma_{m+n}$恒成立。}。
因此，$\gamma$可通过除法用于合并方程两边的$\epsilon_{\mathrm{m}}$项；
在下面一些推导中这会很有用
（注意因为$1\pm\epsilon_{\mathrm{m}}$项表示区间，消去它们是错的：
\begin{align*}
    \frac{(1\pm\epsilon_{\mathrm{m}})^m}{(1\pm\epsilon_{\mathrm{m}})^n}\neq(1\pm\epsilon_{\mathrm{m}})^{m-n}\, ;
\end{align*}
必须换为边界$\gamma_{m+n}$）。

给定一些本身带有一定量误差的计算输入，
观察该误差如何被带到各种基本算术运算中是有益的。
给定都带有之前运算累积误差的
两个值$a(1\pm\gamma_i)$和$b(1\pm\gamma_j)$，考虑它们的积。
利用$\otimes$的定义，结果在区间
\begin{align*}
    a(1\pm\gamma_i)\otimes b(1\pm\gamma_j)\in ab(1\pm\gamma_{i+j+1})
\end{align*}
中，其中我们用了直接从\refeq{3.11}推得的关系$(1\pm\gamma_i)(1\pm\gamma_j)\in(1\pm\gamma_{i+j})$。

该结果的相对误差界定为：
\begin{align*}
    \left|\frac{ab\gamma_{i+j+1}}{ab}\right|=\gamma_{i+j+1}\, ,
\end{align*}
因此最终误差大约为乘积值处ulp的$\displaystyle\frac{1}{2}(i+j+1)$——和我们希望的乘法误差一样好
（除法的情况也一样好）。

不幸的是，加减法中相对误差可能大幅增加。
使用相同运算值定义，考虑
\begin{align*}
    a(1\pm\gamma_i)\oplus b(1\pm\gamma_j)\, ,
\end{align*}
它在区间$a(1\pm\gamma_{i+1})+b(1\pm\gamma_{j+1})$内，
所以绝对误差定界为$|a|\gamma_{i+1}+|b|\gamma_{j+1}$。

如果$a$和$b$同号，则绝对误差定界为$|a+b|\gamma_{i+j+1}$且
相对误差约为算得值附近ulp的$\displaystyle\frac{1}{2}(i+j+1)$。

然而，如果$a$和$b$异号（或者等价地，它们同号但做减法），
则相对误差可能很高。考虑$a\approx-b$的情况：相对误差为
\begin{align*}
    \frac{|a|\gamma_{i+1}+|b|\gamma_{j+1}}{a+b}\approx\frac{2|a|\gamma_{i+j+1}}{a+b}\, .
\end{align*}
分子的大小与原始值$|a|$成正比但除以一个非常小的数，因此相对误差很高。
这种相对误差的大幅增加称为\keyindex{灾难性抵消}{catastrophic cancellation}{}。
等价地，我们从绝对误差取决于$|a|$值大小的事实中感受到了问题所在，
尽管现在问题在于一个远小于$a$的值。

\subsubsection*{运行误差分析}
除了用代数算出误差边界外，我们还可以让计算机在执行计算时为我们完成这项工作。
该方法称为\keyindex{运行误差分析}{running error analysis}{}。
其背后的思想很简单：每次执行浮点运算时，我们也基于\refeq{3.7}计算给出区间的项
以算出目前已积累误差的运行边界。
尽管该方法比推导直接给出误差边界的表达式有更高的运行时开销，
但当推导变得很难时它会很方便。

pbrt提供了简单的类\refvar{EFloat}{}，
绝大部分就像常规的{\ttfamily float}那样
但使用运算符重载提供了浮点的所有常规算术运算并计算它们的误差边界。

和\refchap{几何与变换}的类\refvar{Interval}{}相似，
\refvar{EFloat}{}跟踪一个描述感兴趣的值不确定性的区间。
与\refvar{Interval}{}相比，\refvar{EFloat}{}的区间是
由于中间浮点算术的误差产生的而不是输入参数的不确定性。
\begin{lstlisting}
`\initcode{EFloat Public Methods}{=}\initnext{EFloatPublicMethods}`
`\initvar{EFloat}{}`() { }
`\refvar{EFloat}{}`(float v, float err = 0.f) : `\refvar[EFloat::v]{v}{}`(v), `\refvar[EFloat::err]{err}{}`(err) {
    `\refcode{Store high-precision reference value in EFloat}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\initcode{EFloat Private Data}{=}\initnext{EFloatPrivateData}`
float `\initvar[EFloat::v]{v}{}`;
float `\initvar[EFloat::err]{err}{}`;
\end{lstlisting}

在调试构建中，\refvar{EFloat}{}还维护\refvar[EFloat::v]{v}{}的高精度版本
用作参考值以计算相对误差的精确近似。
在优化构建中，我们一般不为计算该额外值花费开销。
\begin{lstlisting}
`\initcode{Store high-precision reference value in EFloat}{=}`
#ifndef NDEBUG
ld = v;
#endif // NDEBUG
\end{lstlisting}
\begin{lstlisting}
`\refcode{EFloat Private Data}{+=}\lastcode{EFloatPrivateData}`
#ifndef NDEBUG
long double `\initvar[EFloat::ld]{ld}{}`;
#endif // NDEBUG
\end{lstlisting}

该类的加法运算实现本质上是相关定义的实现。我们有：
\begin{align*}
    (a\pm\delta_a)\oplus(b\pm\delta_b) & =((a\pm\delta_a)+(b\pm\delta_b))(1\pm\gamma_1)                                          \\
                                       & =a+b+(\pm\delta_a\pm\delta_b\pm(a+b)\gamma_1\pm\gamma_1\delta_a\pm\gamma_1\delta_b)\, .
\end{align*}
所以（括号里的）绝对误差定界为
\begin{align*}
    \delta_a+\delta_b+\gamma_1(|a+b|+\delta_a+\delta_b)\, .
\end{align*}
\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}` 
`\refvar{EFloat}{}` operator+(`\refvar{EFloat}{}` f) const {
    `\refvar{EFloat}{}` r;
    r.`\refvar[EFloat::v]{v}{}` = `\refvar[EFloat::v]{v}{}` + f.`\refvar[EFloat::v]{v}{}`;
#ifndef NDEBUG
    r.`\refvar[EFloat::ld]{ld}{}` = `\refvar[EFloat::ld]{ld}{}` + f.`\refvar[EFloat::ld]{ld}{}`;
#endif  // DEBUG
    r.`\refvar[EFloat::err]{err}{}` = `\refvar[EFloat::err]{err}{}` + f.`\refvar[EFloat::err]{err}{}` +
        `\refvar{gamma}{}`(1) * (std::abs(`\refvar[EFloat::v]{v}{}` + f.`\refvar[EFloat::v]{v}{}`) + `\refvar[EFloat::err]{err}{}` + f.`\refvar[EFloat::err]{err}{}`);
    return r;
}
\end{lstlisting}

\refvar{EFloat}{}的其他算术运算实现是类似的。

注意该实现忽略了计算误差本身也受到舍入误差影响的问题。
如果这有问题，我们可以切换浮点舍入模式使误差边界总是向正无穷大舍入，
但这会是开销很大的操作，因为它在当前处理器上引发完全的管道刷新
\sidenote{译者注：原文a full pipeline flush。}。
这里我们用默认舍入模式：后文中，当它们用于解决该问题时，
误差边界扩展一个ulp。

\refvar{EFloat}{}中的{\ttfamily float}值可通过类型转换运算符获取；
它有修饰符{\ttfamily explicit}以要求调用者
用显式{\ttfamily (float)}转换来提取浮点值。
使用显式转换降低了无意从\refvar{EFloat}{}到\refvar{Float}{}以及
倒回的风险而丢失积累的误差边界。
\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
explicit operator float() const { return `\refvar[EFloat::v]{v}{}`; }
\end{lstlisting}

如果用\refvar{EFloat}{}而不是浮点类型变量执行一系列计算，
则计算中的任何地方都可以调用方法\refvar{GetAbsoluteError}{()}求得
算得值的绝对误差边界。
\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
float `\initvar{GetAbsoluteError}{}`() const { return `\refvar[EFloat::err]{err}{}`; }
\end{lstlisting}

误差区间边界可通过方法\refvar{UpperBound}{()}和\refvar{LowerBound}{()}获取。
它们的实现分别使用\refvar{NextFloatUp}{()}和\refvar{NextFloatDown}{()}将
返回的值扩展一个ulp，保证区间是保守的。
\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastnext{EFloatPublicMethods}`
float `\initvar{UpperBound}{}`() const { return `\refvar{NextFloatUp}{}`(`\refvar[EFloat::v]{v}{}` + `\refvar[EFloat::err]{err}{}`); }
float `\initvar{LowerBound}{}`() const { return `\refvar{NextFloatDown}{}`(`\refvar[EFloat::v]{v}{}` - `\refvar[EFloat::err]{err}{}`); }
\end{lstlisting}

在调试构建中，可以用方法获取相对误差和维护在\refvar[EFloat::ld]{ld}{}中的精确值。
\begin{lstlisting}
`\refcode{EFloat Public Methods}{+=}\lastcode{EFloatPublicMethods}`
#ifndef NDEBUG
float `\initvar{GetRelativeError}{}`() const { return std::abs((`\refvar[EFloat::ld]{ld}{}` - `\refvar[EFloat::v]{v}{}`)/`\refvar[EFloat::ld]{ld}{}`); }
long double `\initvar{PreciseValue}{}`() const { return `\refvar[EFloat::ld]{ld}{}`; }
#endif
\end{lstlisting}

pbrt还提供了函数\refvar{Quadratic}{()}的变种，
它在可能有误差的系数上运算并返回{\ttfamily t0}和{\ttfamily t1}值以及误差边界。
其实现和常规函数\refvar{Quadratic}{()}一样，只是使用了\refvar{EFloat}{}。
\begin{lstlisting}
`\initcode{EFloat Inline Functions}{=}`
inline bool `\initvar[Quadratic:2]{\refvar{Quadratic}{}}{}`(`\refvar{EFloat}{}` A, `\refvar{EFloat}{}` B, `\refvar{EFloat}{}` C,
                      `\refvar{EFloat}{}` *t0, `\refvar{EFloat}{}` *t1);
\end{lstlisting}

有了浮点误差基本知识，我们现在专注用这些工具提供稳定的相交运算。

\subsection{保守的光线-边界框相交}\label{sub:保守的光线-边界框相交}
浮点舍入误差可能造成光线-边界框相交测试错失光线实际上与框相交了的情况。
尽管光线-边界框相交测试中偶尔有假正例是可以接受的，
但我们希望永远不要错过实际的相交——处理好它对于\refsec{层次包围盒}中
加速数据结构\refvar{BVHAccel}{}的正确性很重要，
这样就不会错过有效的光线-形状相交。
\refsub{光线-边界相交}介绍的光线-边界框测试
基于计算一系列光线-厚板相交来寻找光线上
对应光线进入边界框的参数$t_{\min}$和对应光线退出的$t_{\max}$。
如果$t_{\min}<t_{\max}$，则光线穿过了框；否则就错开了。
用浮点算术计算的$t$值可能有误差——如果算得的$t_{\min}$值
纯粹是因舍入误差比$t_{\max}$大的，相交测试会错误地返回假结果。

回想计算求解光线与在$x$点处垂直于$x$轴的平面
相交的$t$值是$\displaystyle t=\frac{x-o_x}{d_x}$。
表达为浮点计算并运用\refeq{3.7}，我们有
\begin{align*}
    t=(x\ominus o_x)\otimes(1\oslash d_x)\in\frac{x-o_x}{d_x}(1\pm\epsilon)^3\, ,
\end{align*}
所以
\begin{align*}
    t(1\pm\gamma_3)=\frac{x-o_x}{d_x}\, .
\end{align*}
算得的结果$t$与精确结果之间的差定界为$|\gamma_3|t$。

如果我们考虑围绕算得$t$值的、定界了完全精确$t$值的区间，
则我们关心的情况是区间什么时候重叠；
若没有重叠，则比较算得的值可以给出正确结果（\reffig{3.42}）。
若区间重叠，则无法知道$t$值的实际顺序。
这种情况下，在比较之前对$t_{\max}$增加误差边界的两倍$2\gamma_3t_{\max}$，
保证我们对该情况保守地返回真
\sidenote{译者注：关于为什么是两倍，
    我的理解是哪怕极端情况下取到$t_{\max}(1-\gamma_3)(1+2\gamma_3)$，
    因为$\gamma_3$是接近$0$的正数，
    所以$(1-\gamma_3)(1+2\gamma_3)=1+\gamma_3(1-2\gamma_3)>1$，
    此时对$t_{\max}$仍有保守的放大作用。若只取一倍则不能保证这一点。}。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Rayerrortmintmax.tex}
    \caption{如果算得的$t_{\min}$和$t_{\max}$的误差边界重叠，
    比较$t_{\min}<t_{\max}$可能不能实际反映出光线是否命中边界框。
    这种情况下保守地返回真比错过确有的相交更好。
    用$t_{\max}$误差的两倍对其扩展保证比较是保守的。}
    \label{fig:3.42}
\end{figure}

我们现在可以定义\refsub{光线-边界相交}中做出该调整的光线-边界框测试的代码片了。
\begin{lstlisting}
`\initcode{Update tFar to ensure robust ray-bounds intersection}{=}`
tFar *= 1 + 2 * `\refvar{gamma}{}`(3);
\end{lstlisting}

方法\refvar[Bounds3::IntersectP2]{Bounds3::IntersectP}{()}的代码片
\refcode{Update tMax and tyMax to ensure robust bounds intersection}{}和
\refcode{Update tzMax to ensure robust bounds intersection}{}也类似，
此处不再介绍\sidenote{译者注：我加回来了。}。
\begin{lstlisting}
`\initcode{Update tMax and tyMax to ensure robust bounds intersection}{=}`
tMax *= 1 + 2 * `\refvar{gamma}{}`(3);
tyMax *= 1 + 2 * `\refvar{gamma}{}`(3);
\end{lstlisting}
\begin{lstlisting}
`\initcode{Update tzMax to ensure robust bounds intersection}{=}`
tzMax *= 1 + 2 * `\refvar{gamma}{}`(3);
\end{lstlisting}

\subsection{稳定的三角形相交}\label{sub:稳定的三角形相交}
\refsub{三角形相交}中精心设计了光线-三角形相交算法的细节以
避免光线错误地穿过两个相邻三角形共享的边或点而不生成相交。
有该保证的相交算法被形象地称为\keyindex{水密的}{watertight}{}。

回想算法基于把三角形顶点变换到射线端点为原点且射线方向沿$+z$轴对齐的坐标系中。
尽管将顶点位置变换到该坐标系统中可能会引入舍入误差，
但该误差不影响相交测试的水密性，
因为所有的三角形都被施加了同样的变换
（而且该误差非常小，对算得的交点精度没有明显影响）。

给定该坐标系统的顶点，计算\refeq{3.1}中定义的三个边函数在点$(0,0)$处的值；
对应的表达式即\refeq{3.2}非常简单。
算法稳定性的关键是，通过浮点算术，保证边函数值有正确的符号。
一般地，我们有
\begin{align}\label{eq:3.12}
    (a\otimes b)\ominus(c\otimes d)\, .
\end{align}

首先，注意如果$ab=cd$，则\refeq{3.12}的值恰好为零，即使是浮点数也如此。
因此我们只需要证明如果$ab>cd$，则$(a\otimes b)\ominus(c\otimes d)$永不为负。
如果$ab>cd$，则$(a\otimes b)$一定大于或等于$(c\otimes d)$。
反过来，它们的差一定大于或等于零
（这些性质都从浮点算术运算都舍入到最接近的可表示浮点值的事实推出）。

如果边函数的值是零，则无法分辨它是恰好为零还是零附近很小的正值或负值。
这种情况下，代码片\refcode{Fall back to double-precision test at triangle edges}{}重新
用双浮点精度计算边函数值；
给定32位浮点输入，可以证明精度加倍足以准确区分这些情况。

该额外预防措施的开销很小：在8800万次光线相交测试基准中，
只有低于0.0000023\%的情况使用了双精度回退。

\subsection{定界交点误差}\label{sub:定界交点误差}
我们现在应用该机制分析舍入误差来推导算得光线-形状交点绝对误差的保守边界，
这允许我们构造保证包含实际曲面上的交点的边界框（\reffig{3.43}）。
这些边界框为生成将于\refsub{稳定触发的射线端点}介绍的触发的射线端点提供了算法基础。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Intersectionanderrorbox.tex}
    \caption{pbrt中的形状相交算法计算交点，这里用2D设置下的实心圆表示。
        该点的绝对误差定界为$\delta_x$和$\delta_y$，给出了绕该点的小框。
        因为这些边界是保守的，我们知道曲面上的实际交点（空心圆）一定位于框中的某处。}
    \label{fig:3.43}
\end{figure}

从计算交点的传统方法中的误差源开始梳理很有用。
光线追踪中计算3D交点的常见做法是首先求解参数射线方程$\bm o+t\bm d$中
射线与曲面相交的$t_{\text{hit}}$值，
再用$\bm p=\bm o+t_{\text{hit}}\bm d$计算命中点$\bm p$。
如果$t_{\text{hit}}$携带一些误差$\delta_t$，
则我们可以在算得的交点中定界该误差。
例如考虑$x$坐标，我们有
\begin{align*}
    x & =o_x\oplus(t_{\text{hit}}\pm\delta_t)\otimes d_x                                                              \\
      & \in o_x\oplus(t_{\text{hit}}\pm\delta_t)d_x(1\pm\gamma_1)                                                     \\
      & \subset o_x(1\pm\gamma_1)+(t_{\text{hit}}\pm\delta_t)d_x(1\pm\gamma_2)                                        \\
      & =o_x+t_{\text{hit}}d_x+[\pm o_x\gamma_1\pm\delta_td_x\pm t_{\text{hit}}d_x\gamma_2\pm\delta_td_x\gamma_2]\, .
\end{align*}
（方括号中的）误差项定界为
\begin{align}\label{eq:3.13}
    \gamma_1|o_x|+\delta_t(1+\gamma_2)|d_x|+\gamma_2|t_{\text{hit}}d_x|\, .
\end{align}

从\refeq{3.13}中可以看出两点：第一，贡献于算得交点误差的项
（$o_x$、$d_x$和$t_{\text{hit}}d_x$）的量级可能与交点的量级相差很大。
因此在交点算得的值中存在灾难性抵消的危险。
第二，光线相交算法一般执行十来次浮点运算以计算$t$值，
反过来意味着我们估计$\delta_t$至少有$\gamma_nt$的量级，
其中$n$为十量级（且由于灾难性抵消可能更大）。
这些项的每一个与点$x$的大小都可能是相当的。

总之这些因素会导致算得交点中有较大误差。
我们将很快开发更好方法。

\subsubsection*{重投影：二次曲面}
我们想可靠地计算曲面上仅有几个ulp误差的交点而不是
用参数射线方程算得可能有上百ulp误差的交点。
以前对于光线-多边形相交，Woo等\parencite*{536271}建议用
第一个算得的交点作为第二次光线-平面相交的起始点。
从\refeq{3.13}的边界中，我们可以看到为什么第二个交点会比第一个接近曲面得多：
沿第二射线的$t_{\text{hit}}$值非常接近于零，
所以$t_{\text{hit}}$中的绝对误差大小会非常小，
因此在参数射线方程中使用该值会给出非常接近曲面的点（\reffig{3.44}）。
而且，射线端点会有与交点同样的量级，所以该项不会引入太多额外误差。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Reintersectrefine.tex}
    \caption{再相交以提升算得交点的准确度。给定一射线和曲面，
        已经用射线方程算得初始交点（实心圆）。
        该点可能因为舍入误差而非常不准确但可以用作第二次
        光线-形状相交的端点。从该二次相交算得的交点（空心圆）
        接近曲面得多，尽管它可能因为第一次相交计算中的误差而
        偏移了真正的交点。}
    \label{fig:3.44}
\end{figure}

尽管用该方法算得的第二个交点接近表面平面得多，
它仍然因为第一次相交计算的误差而受到偏移误差的影响。
射线端点离交点越远（且因此$t_{\text{hit}}$中的绝对误差越大），该误差就越大。
尽管有该误差，该方法也有优点：比起在曲面上方或下面有一定距离
（而且可能离最准确的交点很远）的点，
算得非常接近实际曲面的交点对我们更有利，哪怕它偏移了可能最准确的交点。

比起做可能不仅计算开销大而且在算得$t$值中仍有误差的完整再相交计算，
一个高效方法是通过将算得交点重投影到曲面上来改善它们。
这些重投影点的误差边界通常极其小。

要注意的是这些重投影误差边界不会涵盖原始交点$\bm p$中的切向误差——
这里主要关注检测可能让重投影点$\bm p'$掉到曲面之下的误差。

考虑光线-球体相交：给定算得的交点（例如来自射线方程）$\bm p$以及
位于原点处半径为$r$的球体，我们可以通过用球体半径与算得的该点到原点距离的比例
缩放该点来将其重投影到球面上，并用下式计算新点$\bm p'=(x',y',z')$
\begin{align*}
    x'=x\frac{r}{\sqrt{x^2+y^2+z^2}}\, ,
\end{align*}
等等。浮点计算\sidenote{译者注：建议读者动手推导一下。}为
\begin{align*}
    x' & =x\otimes r\oslash \text{sqrt}((x\otimes x)\oplus(y\otimes y)\oplus(z\otimes z))                                                                                                \\
       & \in\frac{xr(1\pm\epsilon_{\mathrm{m}})^2}{\sqrt{x^2(1\pm\epsilon_{\mathrm{m}})^3+y^2(1\pm\epsilon_{\mathrm{m}})^3+z^2(1\pm\epsilon_{\mathrm{m}})^2}(1\pm\epsilon_{\mathrm{m}})} \\
       & \subset\frac{xr(1\pm\gamma_2)}{\sqrt{x^2(1\pm\gamma_3)+y^2(1\pm\gamma_3)+z^2(1\pm\gamma_2)}(1\pm\gamma_1)}\, .
\end{align*}
因为$x^2$、$y^2$和$z^2$都是正数，平方根中的项可以共享同样的$\gamma$项，所以我们有
\begin{align}\label{eq:3.14}
    x' & \in\frac{xr(1\pm\gamma_2)}{\sqrt{(x^2+y^2+z^2)(1\pm\gamma_4)}(1\pm\gamma_1)}\nonumber  \\
       & =\frac{xr(1\pm\gamma_2)}{\sqrt{x^2+y^2+z^2}\sqrt{1\pm\gamma_4}(1\pm\gamma_1)}\nonumber \\
       & \subset \frac{xr}{\sqrt{x^2+y^2+z^2}}(1\pm\gamma_5)\nonumber                           \\
       & =x'(1\pm\gamma_5)\, .
\end{align}

因此，球面上的点的重投影$x$坐标的绝对误差
定界为$\gamma_5|x'|$（且$y'$和$z'$同理）且因此每个维度不超过2.5个ulp。

这里是为形状\refvar{Sphere}{}重投影交点的代码片。
\begin{lstlisting}
`\initcode{Refine sphere intersection point}{=}`
pHit *= `\refvar[Sphere::radius]{radius}{}` / `\refvar{Distance}{}`(pHit, `\refvar{Point3f}{}`(0, 0, 0));
\end{lstlisting}

误差边界遵循\refeq{3.14}。
\begin{lstlisting}
`\initcode{Compute error bounds for sphere intersection}{=}`
`\refvar{Vector3f}{}` pError = `\refvar{gamma}{}`(5) * `\refvar[Vector3::Abs]{Abs}{}`((`\refvar{Vector3f}{}`)pHit);
\end{lstlisting}

其他二次曲面的重投影算法和误差边界也可以类似地定义：例如，对于对齐$z$轴的圆柱体，
只有$x$和$y$坐标需要重投影，$x$和$y$中的误差边界变为仅有其大小的$\gamma_3$倍。
\begin{lstlisting}
`\initcode{Refine cylinder intersection point}{=}`
`\refvar{Float}{}` hitRad = std::sqrt(pHit.x * pHit.x + pHit.y * pHit.y);
pHit.x *= `\refvar[Cylinder::radius]{radius}{}` / hitRad;
pHit.y *= `\refvar[Cylinder::radius]{radius}{}` / hitRad;
\end{lstlisting}
\begin{lstlisting}
`\initcode{Compute error bounds for cylinder intersection}{=}`
`\refvar{Vector3f}{}` pError = `\refvar{gamma}{}`(3) * `\refvar[Vector3::Abs]{Abs}{}`(`\refvar{Vector3f}{}`(pHit.x, pHit.y, 0));
\end{lstlisting}

圆盘形状特别简单；我们只需设置点的$z$坐标位于圆盘平面上。
\begin{lstlisting}
`\initcode{Refine disk intersection point}{=}`
pHit.z = `\refvar[Disk::height]{height}{}`;
\end{lstlisting}

反过来，我们有零误差的点；它恰好位于圆盘表面上。
\begin{lstlisting}
`\initcode{Compute error bounds for disk intersection}{=}`
`\refvar{Vector3f}{}` pError(0, 0, 0);
\end{lstlisting}

\subsubsection*{参数求值：三角形}
另一个高效计算精确交点的方法是用形状的参数表示计算准确交点。
例如，\refsub{三角形相交}的三角形相交算法计算三个边函数值$e_0$、$e_1$和$e_2$并且
如果全部三个都有相同的符号则报告相交。
它们的值可用于寻找重心坐标
\begin{align*}
    b_i=\frac{e_i}{e_0+e_1+e_2}\, .
\end{align*}

三角形顶点处的属性$v_i$（包括顶点位置）可以在三角形平面上用下式插值
\begin{align*}
    v'=b_0v_0+b_1v_1+b_2v_2\, .
\end{align*}

我们现在可以证明用这种方式插值顶点位置给出的点非常接近三角形面。
首先考虑预先计算的$e_i$之和的倒数：
\begin{align*}
    d & =1\oslash(e_0\oplus e_1\oplus e_2)                                                                                \\
      & \in\frac{1}{(e_0+e_1)(1\pm\epsilon_{\mathrm{m}})^2+e_2(1\pm\epsilon_{\mathrm{m}})}(1\pm\epsilon_{\mathrm{m}})\, .
\end{align*}
因为如果相交则所有$e_i$同号，所有我们可以合并$e_i$项并保守地定界$d$：
\begin{align*}
    d & \in\frac{1}{(e_0+e_1+e_2)(1\pm\epsilon_{\mathrm{m}})^2}(1\pm\epsilon_{\mathrm{m}}) \\
      & \subset \frac{1}{e_0+e_1+e_2}(1\pm\gamma_3)\, .
\end{align*}
如果我们现在考虑在三角形中插值对应于边函数值的位置的$x$坐标，我们有
\begin{align*}
    x' & =((e_0\otimes x_0)\oplus(e_1\otimes x_1)\oplus(e_2\otimes x_2))\otimes d                                                                     \\
       & \in(e_0x_0(1\pm\epsilon_{\mathrm{m}})^3+e_1x_1(1\pm\epsilon_{\mathrm{m}})^3+e_2x_2(1\pm\epsilon_{\mathrm{m}})^2)d(1\pm\epsilon_{\mathrm{m}}) \\
       & \subset (e_0x_0(1\pm\gamma_4)+e_1x_1(1\pm\gamma_4)+e_2x_2(1\pm\gamma_3))d\, .
\end{align*}
使用$d$上的边界\sidenote{译者注：原书写的$x\in\ldots$可能是笔误，已修正。}，
\begin{align*}
    x' & \in\frac{e_0x_0(1\pm\gamma_7)+e_1x_1(1\pm\gamma_7)+e_2x_2(1\pm\gamma_6)}{e_0+e_1+e_2} \\
       & =b_0x_0(1\pm\gamma_7)+b_1x_1(1\pm\gamma_7)+b_2x_2(1\pm\gamma_6)\, .
\end{align*}
因此，我们最终可以看到算得的$x'$值中的绝对误差在区间
\begin{align*}
    \pm b_0x_0\gamma_7\pm b_1x_1\gamma_7\pm b_2x_2\gamma_7\,
\end{align*}
内，它定界为
\begin{align}\label{eq:3.15}
    \gamma_7(|b_0x_0|+|b_1x_1|+|b_2x_2|)\, .
\end{align}
（注意$b_2x_2$项本应有因子$\gamma_6$而不是$\gamma_7$，
但两者的差别非常小，所以我们选择稍稍简化最终表达式。）
对$y'$和$z'$也有同样的等价边界。

\refeq{3.15}让我们定界\refvar{Triangle::Intersect}{()}中计算的插值点的误差。
\begin{lstlisting}
`\initcode{Compute error bounds for triangle intersection}{=}`
`\refvar{Float}{}` xAbsSum = (std::abs(b0 * p0.x) + std::abs(b1 * p1.x) +
                 std::abs(b2 * p2.x));
`\refvar{Float}{}` yAbsSum = (std::abs(b0 * p0.y) + std::abs(b1 * p1.y) +
                 std::abs(b2 * p2.y));
`\refvar{Float}{}` zAbsSum = (std::abs(b0 * p0.z) + std::abs(b1 * p1.z) +
                 std::abs(b2 * p2.z));
`\refvar{Vector3f}{}` pError = `\refvar{gamma}{}`(7) * `\refvar{Vector3f}{}`(xAbsSum, yAbsSum, zAbsSum);
\end{lstlisting}

\subsubsection*{其他形状}
对于我们可能不想推导重投影方法和严格误差边界的形状，
运行误差分析会非常有用：我们用\refvar{EFloat}{}代替\refvar{Float}{}实现所有相交计算，
计算$t_{\text{hit}}$值，并用参数射线方程计算命中点。
然后我们可以通过方法\refvar{GetAbsoluteError}{()}求得
算得的交点中误差的保守边界。
\begin{lstlisting}
`\initcode{Compute error bounds for intersection computed with ray equation}{}`
`\refvar{EFloat}{}` px = ox + tShapeHit * dx;
`\refvar{EFloat}{}` py = oy + tShapeHit * dy;
`\refvar{EFloat}{}` pz = oz + tShapeHit * dz;
`\refvar{Vector3f}{}` pError = `\refvar{Vector3f}{}`(px.`\refvar{GetAbsoluteError}{}`(), py.`\refvar{GetAbsoluteError}{}`(),
                           pz.`\refvar{GetAbsoluteError}{}`());
\end{lstlisting}

pbrt中该方法用于圆锥体、抛物面和双曲面。
\begin{lstlisting}
`\initcode{Compute error bounds for cone intersection}{=}`
`\refcode{Compute error bounds for intersection computed with ray equation}{}`
\end{lstlisting}

因为形状\refvar{Curve}{}让自己面向入射光线，
离开它的光线为了在曲线再次朝向它们时不会错误地再相交，
一定偏移了曲线宽度的两倍。
\begin{lstlisting}
`\initcode{Compute error bounds for curve intersection}{=}`
`\refvar{Vector3f}{}` pError(2 * hitWidth, 2 * hitWidth, 2 * hitWidth);
\end{lstlisting}

\subsubsection*{变换的效应}
为了定界算得交点中的误差而要注意的最后一点细节是变换的效应，
当它们施加到算得的交点上时会引入额外舍入误差。

pbrt中的二次曲面\refvar{Shape}{}在执行光线-物体相交前
将世界空间射线变换到物体空间，之后再将算得的交点变换回世界空间。
为了保证交点周围有稳定的世界空间边界，需要考虑这两步变换引入的舍入误差。

如果可能的话，最好是尽力避免光线和交点的坐标系变换。
例如，将三角形顶点变换到世界空间并与世界空间光线相交比
将光线变换到物体空间再将交点变换到世界空间更好
\footnote{尽管（例如）把三角形顶点变换到世界空间时引入了舍入误差，
    但该误差不会增加计算交点时需要处理的误差。
    换句话说，变换后的顶点可能代表一个扰动过的场景表示，
    但它们是给定变换下最精确的表示了。}。
变换仍然是有用的——例如对于二次曲面和对象实例化，
所以我们将展示怎样定界它们引入的误差。

我们将从考虑变换准确点$(x,y,z)$引入的误差开始——即该点没有任何累积误差。
给定元素记为$m_{i,j}$的$4\times4$非投影变换矩阵，变换后的坐标$x'$为
\begin{align*}
    x' & =((m_{0,0}\otimes x)\oplus(m_{0,1}\otimes y))\oplus((m_{0,2}\otimes z)\oplus m_{0,3})                                                                      \\
       & \in m_{0,0}x(1\pm\epsilon_{\mathrm{m}})^3+m_{0,1}y(1\pm\epsilon_{\mathrm{m}})^3+m_{0,2}z(1\pm\epsilon_{\mathrm{m}})^3+m_{0,3}(1\pm\epsilon_{\mathrm{m}})^2 \\
       & \subset (m_{0,0}x+m_{0,1}y+m_{0,2}z+m_{0,3})+\gamma_3(\pm m_{0,0}x\pm m_{0,1}y\pm m_{0,2}z\pm m_{0,3})                                                     \\
       & \subset (m_{0,0}x+m_{0,1}y+m_{0,2}z+m_{0,3})\pm\gamma_3(|m_{0,0}x|+|m_{0,1}y|+|m_{0,2}z|+|m_{0,3}|)\, .
\end{align*}
因此，结果中的绝对误差定界为
\begin{align}\label{eq:3.16}
    \gamma_3(|m_{0,0}x|+|m_{0,1}y|+|m_{0,2}z|+|m_{0,3}|)\, .
\end{align}
对于变换后的$y'$和$z'$坐标也有同样的边界。

我们将用该结果向类\refvar{Transform}{}增加一种
也根据施加的变换在变换后的点中返回绝对误差的方法。
\begin{lstlisting}
`\refcode{Transform Inline Functions}{+=}\lastcode{TransformInlineFunctions}`
template <typename T> inline `\refvar{Point3}{}`<T>
`\refvar{Transform}{}`::operator()(const `\refvar{Point3}{}`<T> &p, `\refvar{Vector3}{}`<T> *pError) const {
    T x = p.x, y = p.y, z = p.z;
    `\refcode{Compute transformed coordinates from point pt}{}`
    `\refcode{Compute absolute error for transformed point}{}`
    if (wp == 1) return `\refvar{Point3}{}`<T>(xp, yp, zp);
    else         return `\refvar{Point3}{}`<T>(xp, yp, zp) / wp;
}
\end{lstlisting}

代码片\refcode{Compute transformed coordinates from point pt}{}像\refsec{施加变换}那样
实现同样的矩阵/点乘法。
\begin{lstlisting}
`\initcode{Compute transformed coordinates from point pt}{=}`
T xp = `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][0] * x + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][1] * y + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][2] * z + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][3];
T yp = `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][0] * x + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][1] * y + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][2] * z + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][3];
T zp = `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][0] * x + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][1] * y + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][2] * z + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][3];
T wp = `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[3][0] * x + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[3][1] * y + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[3][2] * z + `\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[3][3];
\end{lstlisting}

注意如果矩阵是投影的且投影后点的齐次$w$坐标不是一，则计算误差边界的代码是错的；
目前该小bug对于pbrt对该方法的使用不是问题。
\begin{lstlisting}
`\initcode{Compute absolute error for transformed point}{=}`
T xAbsSum = (std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][0] * x) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][1] * y) +
             std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][2] * z) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[0][3]));
T yAbsSum = (std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][0] * x) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][1] * y) +
             std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][2] * z) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[1][3]));
T zAbsSum = (std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][0] * x) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][1] * y) +
             std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][2] * z) + std::abs(`\refvar[Transform::m]{m}{}`.`\refvar[Matrix4x4::m]{m}{}`[2][3]));
*pError = `\refvar{gamma}{}`(3) * `\refvar{Vector3}{}`<T>(xAbsSum, yAbsSum, zAbsSum);
\end{lstlisting}

\refeq{3.16}的结果假设被变换的点是准确的。
如果该点自己有误差边界$\delta_x$、$\delta_y$和$\delta_z$，
则变换后的$x$坐标为
\begin{align*}
    x'=(m_{0,0}\otimes (x\pm\delta_x)\oplus m_{0,1}\otimes (y\pm\delta_y))\oplus(m_{0,2}\otimes (z\pm\delta_z)\oplus m_{0,3})\, .
\end{align*}
运用浮点加法和乘法误差边界的定义，我们有：
\begin{align*}
    x' & =m_{0,0}(x\pm\delta_x)(1\pm\epsilon_{\mathrm{m}})^3+m_{0,1}(y\pm\delta_y)(1\pm\epsilon_{\mathrm{m}})^3+m_{0,2}(z\pm\delta_z)(1\pm\epsilon_{\mathrm{m}})^3+m_{0,3}(1\pm\epsilon_{\mathrm{m}})^2\, .
\end{align*}
用$\gamma$转换，我们可以求得绝对误差项定界为
\begin{align}\label{eq:3.17}
    (\gamma_3+1)(|m_{0,0}|\delta_x+|m_{0,1}|\delta_y+|m_{0,2}|\delta_z)+\gamma_3(|m_{0,0}x|+|m_{0,1}y|+|m_{0,2}z|+|m_{0,3}|)\, .
\end{align}

类\refvar{Transform}{}也提供了{\ttfamily operator()}接收一点
及其自己的绝对误差并用\refeq{3.17}在结果中返回绝对误差。
其定义很简单，所以本文这里不再介绍。
\begin{lstlisting}
`\refcode{Transform Public Methods}{+=}\lastnext{TransformPublicMethods}`
template <typename T> inline `\refvar{Point3}{}`<T>
operator()(const `\refvar{Point3}{}`<T> &p, const `\refvar{Vector3}{}`<T> &pError,
           `\refvar{Vector3}{}`<T> *pTransError) const;
\end{lstlisting}

类\refvar{Transform}{}也提供了变换向量和射线的方法，返回结果误差。
向量误差边界的推导（以及实现）和点非常类似，所以这里不再介绍。
\begin{lstlisting}
`\refcode{Transform Public Methods}{+=}\lastcode{TransformPublicMethods}`
template <typename T> inline `\refvar{Vector3}{}`<T>
operator()(const `\refvar{Vector3}{}`<T> &v, `\refvar{Vector3}{}`<T> *vTransError) const;
template <typename T> inline `\refvar{Vector3}{}`<T>
operator()(const `\refvar{Vector3}{}`<T> &v, const `\refvar{Vector3}{}`<T> &vError,
           `\refvar{Vector3}{}`<T> *vTransError) const;
\end{lstlisting}

该方法用于\refvar{SurfaceInteraction}{}在方法\refvar{Transform}{::operator()}中变换交点及其误差边界。
\begin{lstlisting}
`\initcode{Transform p and pError in SurfaceInteraction}{=}`
ret.`\refvar[Interaction::p]{p}{}` = (*this)(si.`\refvar[Interaction::p]{p}{}`, si.`\refvar{pError}{}`, &ret.`\refvar{pError}{}`);
\end{lstlisting}

\subsection{稳定触发的射线端点}\label{sub:稳定触发的射线端点}
算得交点及其误差边界给了我们限定一片空间区域的小3D框。
我们知道精确交点必在该框中的某处且因此曲面必穿过该框
（至少足以表示点在哪里相交）（回想\reffig{3.43}）。
有了这些框就能定位离开曲面的射线端点，
这样它们总在曲面的正确一侧而不与之错误地再相交。
当追踪触发的离开交点$\bm p$的光线时，我们充分偏移其端点
以保证它们错开误差框边界而不会与曲面错误地再相交。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Offsetrayoriginwithnormalanderror.tex}
    \caption{给定算得的交点（实心圆）和曲面法线（箭头）以及误差边界（矩形），
        我们计算两个沿法线偏移足够远以至于不会与误差边界相交的平面。
        算得的交点沿法线落在这些平面上的点给了我们触发的射线的端点（空心圆）；
        基于射线方向选择两个中的一个使得触发的射线不会穿过误差边界框。
        通过构造，这样的射线不会错误地与实际曲面（粗线）再相交。}
    \label{fig:3.45}
\end{figure}

为了保证触发射线的端点确实在曲面正确的一侧，
我们沿法线移动足够远使得垂直于法线的平面在误差边界框之外。
为了理解怎样做到这点，考虑算得的交点位于原点，过该交点的平面方程为
\begin{align*}
    f(x,y,z)=n_xx+n_yy+n_zz\, ,
\end{align*}
平面被隐式定义为$f(x,y,z)=0$，法线为$(n_x,n_y,n_z)$。

对于不在平面上的点，平面方程的值$f(x,y,z)$给出了过该点的平面沿法线的偏移量。
我们想对误差边界框的八个顶点求$f(x,y,z)$的最大值\sidenote{译者注：指最大绝对值。}；
如果我们将平面偏移正负偏移量，我们就有两个不与误差框相交的
且应该在曲面（局部）对侧的平面，至少是在算得的交点沿法线偏移的两侧（\reffig{3.45}）。

若误差边界框八个顶点给定为$(\pm\delta_x,\pm\delta_y,\pm\delta_z)$，
则易算出$f(x,y,z)$最大值：
\begin{align*}
    d=|n_x|\delta_x+|n_y|\delta_y+|n_z|\delta_z\, .
\end{align*}

通过沿曲面法线偏移的这种方式计算触发射线的端点有几个优点：
假设曲面是局部平坦的（这是合理假设，尤其是在交点误差边界非常小的尺度上时），
沿法线移动允许我们在移动最短距离时能从曲面的一侧到另一侧。
通常，最小化射线端点偏移距离对于保持阴影和反射细节是可取的。
\begin{lstlisting}
`\refcode{Geometry Inline Functions}{+=}\lastnext{GeometryInlineFunctions}`
inline `\refvar{Point3f}{}` `\initvar{OffsetRayOrigin}{}`(const `\refvar{Point3f}{}` &p, const `\refvar{Vector3f}{}` &pError,
                               const `\refvar{Normal3f}{}` &n, const `\refvar{Vector3f}{}` &w) {
    `\refvar{Float}{}` d = `\refvar{Dot}{}`(`\refvar[Vector3::Abs]{Abs}{}`(n), pError);
    `\refvar{Vector3f}{}` offset = d * `\refvar{Vector3f}{}`(n);
    if (`\refvar{Dot}{}`(w, n) < 0)
        offset = -offset;
    `\refvar{Point3f}{}` po = p + offset;
    `\refcode{Round offset point po away from p}{}`
    return po;
}
\end{lstlisting}

\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Offsetandroundup.tex}
    \caption{\protect\refvar{OffsetRayOrigin}{()}中算得的
    偏移点{\ttfamily p+offset}的舍入值结果可能是在误差框的内部而不是边界上，
    如果舍入点在曲面的错误一侧，则这反过来引入了错误自相交的风险。
    推进算得点的每个坐标远离{\ttfamily p}一个浮点值保证了它在误差框之外。}
    \label{fig:3.46}
\end{figure}

当计算偏移点时我们还必须处理舍入误差：
当{\ttfamily offset}加到{\ttfamily p}上时，
结果一般需要舍入到最近的浮点值。
反过来，它可能朝{\ttfamily p}向下舍入使得
结果点在误差框的内部而不是在边界上（\reffig{3.46}）。
因此，这里将偏移点舍入远离{\ttfamily p}以保证它不在框内
\footnote{细心的读者现在可能担心当计算传入该函数的误差边界时舍入误差会有何影响。
    确实，这些边界的计算也该朝着正无穷舍入。
    但我们忽略了这个问题，因为这里额外的一个ulp偏移量足够补偿该误差了。}。

或者，也可以把浮点舍入模式设为朝正或负无穷舍入（基于值的符号）。
改变舍入模式通常开销非常大，所以我们这里只是将浮点值移动一个ulp。
有时这会造成已经在误差框外的值稍稍超出它，
但因为浮点间隔如此之小所以这在实践中是没问题的。
\begin{lstlisting}
`\initcode{Round offset point po away from p}{=}`
for (int i = 0; i < 3; ++i) {
    if (offset[i] > 0)      po[i] = `\refvar{NextFloatUp}{}`(po[i]);
    else if (offset[i] < 0) po[i] = `\refvar{NextFloatDown}{}`(po[i]);
}
\end{lstlisting}

有了函数\refvar{OffsetRayOrigin}{()}，我们现在可以实现\refvar{Interaction}{}中
生成离开交点射线的方法了。
\begin{lstlisting}
`\refcode{Interaction Public Methods}{+=}\lastnext{InteractionPublicMethods}` 
`\refvar{Ray}{}` `\initvar{SpawnRay}{}`(const `\refvar{Vector3f}{}` &d) const {
    `\refvar{Point3f}{}` o = `\refvar{OffsetRayOrigin}{}`(`\refvar[Interaction::p]{p}{}`, `\refvar{pError}{}`, `\refvar[Interaction::n]{n}{}`, d);
    return `\refvar{Ray}{}`(o, d, `\refvar{Infinity}{}`, `\refvar[Interaction::time]{time}{}`, `\refvar{GetMedium}{}`(d));
}
\end{lstlisting}

目前我们开发的方法解决了离开曲面射线端点处的浮点误差影响；
有一个与面光源的阴影射线相关的问题：
我们想求得任何与非常接近光源且实际阻挡了它的形状的相交处，
同时避免报告与光源曲面的错误相交。
不幸的是，我们的实现没有解决这个问题，
所以我们将阴影射线的\refvar{tMax}{}值设为一以下，
这样它们会在光源曲面之前停止。
\begin{lstlisting}
`\refcode{Interaction Public Methods}{+=}\lastnext{InteractionPublicMethods}`
`\refvar{Ray}{}` `\initvar{SpawnRayTo}{}`(const `\refvar{Point3f}{}` &p2) const {
    `\refvar{Point3f}{}` origin = `\refvar{OffsetRayOrigin}{}`(`\refvar[Interaction::p]{p}{}`, `\refvar{pError}{}`, `\refvar[Interaction::n]{n}{}`, p2 - `\refvar[Interaction::p]{p}{}`);
    `\refvar{Vector3f}{}` d = p2 - origin;
    return `\refvar{Ray}{}`(origin, d, 1 - `\refvar{ShadowEpsilon}{}`, `\refvar[Interaction::time]{time}{}`, `\refvar{}{}`GetMedium(d));
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{Global Constants}{+=}\lastnext{GlobalConstants}`
const `\refvar{Float}{}` `\initvar{ShadowEpsilon}{}` = 0.0001f;
\end{lstlisting}

另一个接收\refvar{Interaction}{}的\refvar{SpawnRayTo}{()}变体是类似的。

为了保持稳定触发射线端点，最后要解决的问题是：执行变换时引入的误差。
给定一个坐标系内的射线，其端点经仔细计算后位于某曲面适当的一侧，
将该射线变换到另一坐标系可能会在变换后的端点中引入误差使得
端点不再位于触发它的曲面的正确一侧。

因此，无论何时用（\refsub{射线}实现的）{\ttfamily Transform::operator()}的\refvar{Ray}{}变体，
其端点都朝该变换引入的误差边界的边上推进。
如果有的话，这保证了端点保守地留在触发它的曲面的正确一侧。
\begin{lstlisting}
`\initcode{Offset ray origin to edge of error bounds and compute tMax}{=}`
`\refvar{Float}{}` lengthSquared = d.`\refvar{LengthSquared}{}`();
`\refvar{Float}{}` tMax = r.`\refvar{tMax}{}`;
if (lengthSquared > 0) {
    `\refvar{Float}{}` dt = `\refvar{Dot}{}`(`\refvar[Vector3::Abs]{Abs}{}`(d), oError) / lengthSquared;
    o += d * dt;
    tMax -= dt;
}
\end{lstlisting}

\subsection{避免射线端点之后的相交}\label{sub:避免射线端点之后的相交}

定界算得的交点的误差允许我们计算保证位于曲面正确一侧的射线端点，
这样有无限精度的射线不会与它离开的曲面错误相交。
然而还必须解决舍入误差的另一个来源：
为光线-形状相交计算的参数$t$值的误差。
舍入误差会使相交算法为交点计算的值$t>0$，
哪怕实际相交的$t$值为负（且因此应被忽略掉）。

可以证明一些相交测试算法总返回具有正确符号的$t$值；
这是最好的情况，因为无需额外计算来定界算得$t$值的实际误差。
例如，考虑射线-轴对齐厚板计算：$t=(x\ominus o_x)\oslash d_x$。
IEEE保证若$a>b$，则$a\ominus b\ge0$（且若$a<b$，则$a\ominus b\le0$）。
为了理解为何会这样，注意若$a>b$，则实数$a-b$必大于零。
当舍入到浮点数时，结果一定要么为零要么是正浮点；
最接近的浮点数不可能是负浮点数。
其次，浮点除法返回正确的符号；
这些合起来保证了算得的$t$值符号是正确的
（或者$t=0$，但这种情况也行，因为我们的相交测试会仔细选择$t>0$）。

对于使用\refvar{EFloat}{}的形状相交例程，最后算得的$t$值附有关联的误差边界，
不再需要额外计算执行该测试了。详见\refsub{相交测试2}定义的
代码片\refcode{Check quadric shape t0 and t1 for nearest intersection}{}。

\subsubsection*{三角形}

高效的相交代码对于更常用的形状更加重要，我们想为其避免\refvar{EFloat}{}引入的计算开销。
对于这些形状，我们可以为算得$t$值推导求值高效的误差保守边界。
\refsub{三角形相交}的光线-三角形相交算法通过计算三个边函数值$e_i$并
用它们计算变换后的顶点$z$坐标$z_i$的重心加权和以计算最后的$t$值：
\begin{align}\label{eq:3.18}
    t=\frac{e_0z_0+e_1z_1+e_2z_2}{e_0+e_1+e_2}\, .
\end{align}

通过依次定界这些项和最后$t$值的误差，我们可保守地检查它们是否为正。
\begin{lstlisting}
`\initcode{Ensure that computed triangle t is conservatively greater than zero}{=}`
`\refcode{Compute $\delta_z$ term for triangle t error bounds}{}`
`\refcode{Compute $\delta_x$ and $\delta_y$ terms for triangle t error bounds}{}`
`\refcode{Compute $\delta_e$ term for triangle t error bounds}{}`
`\refcode{Compute $\delta_t$ term for triangle t error bounds and check t}{}`
\end{lstlisting}

给定端点为$\bm o$、方向为$\bm d$的射线$\bm r$以及三角形顶点$\bm p$，
投影的$z$坐标为
\begin{align*}
    z=(1\oslash d_z)\otimes(p_z-o_z)\, .
\end{align*}

运用常规方法，我们可以发现
\sidenote{译者注：我猜测同理于\protect\refsub{保守的光线-边界框相交}。}
对于三角形三个顶点的每一个$\bm p_i$，
其$z_i$中的最大误差定界为$\gamma_3|z_i|$，
且我们因此会发现\emph{任何}$z$位置的误差保守上界取为这些误差的最大值：
\begin{align*}
    \delta_z=\gamma_3\max_i{|z_i|}\, .
\end{align*}
\begin{lstlisting}
`\initcode{Compute $\delta_z$ term for triangle t error bounds}{=}`
`\refvar{Float}{}` maxZt = `\refvar{MaxComponent}{}`(`\refvar[Vector3::Abs]{Abs}{}`(`\refvar{Vector3f}{}`(p0t.z, p1t.z, p2t.z)));
`\refvar{Float}{}` deltaZ = `\refvar{gamma}{}`(3) * maxZt;
\end{lstlisting}

边函数值计算为两个变换后的$x$和$y$顶点位置之积的差：
\begin{align*}
    e_0 & =(x_1\otimes y_2)\ominus(y_1\otimes x_2)\, , \\
    e_1 & =(x_2\otimes y_0)\ominus(y_2\otimes x_0)\, , \\
    e_2 & =(x_0\otimes y_1)\ominus(y_0\otimes x_1)\, .
\end{align*}

变换后的位置$x_i$和$y_i$的误差边界
\sidenote{译者注：我猜测是根据代码片\protect\refcode{Transform triangle vertices to ray coordinate space}{}的
    步骤推导出来的，计算形式为$(\ominus)\oplus(-(\oslash)\otimes(\ominus))$，可对应到$\gamma_5$。}为
\begin{align*}
    \delta_x & =\gamma_5(\max_i{|x_i|}+\max_i{|z_i|})\, , \\
    \delta_y & =\gamma_5(\max_i{|y_i|}+\max_i{|z_i|})\, .
\end{align*}

\begin{lstlisting}
`\initcode{Compute $\delta_x$ and $\delta_y$ terms for triangle t error bounds}{=}`
`\refvar{Float}{}` maxXt = `\refvar{MaxComponent}{}`(`\refvar[Vector3::Abs]{Abs}{}`(`\refvar{Vector3f}{}`(p0t.x, p1t.x, p2t.x)));
`\refvar{Float}{}` maxYt = `\refvar{MaxComponent}{}`(`\refvar[Vector3::Abs]{Abs}{}`(`\refvar{Vector3f}{}`(p0t.y, p1t.y, p2t.y)));
`\refvar{Float}{}` deltaX = `\refvar{gamma}{}`(5) * (maxXt + maxZt);
`\refvar{Float}{}` deltaY = `\refvar{gamma}{}`(5) * (maxYt + maxZt);
\end{lstlisting}

取全部三个顶点的最大误差，边函数中积$x_i\otimes y_j$定界为
\begin{align*}
    (\max_i{|x_i|}+\delta_x)(\max_i{|y_i|}+\delta_y)(1\pm\epsilon_{\mathrm{m}})\, ,
\end{align*}
其绝对误差边界为
\begin{align*}
    \delta_{xy}=\gamma_1\max_i{|x_i|}\max_i{|y_i|}+\delta_y\max_i{|x_i|}+\delta_x\max_i{|y_i|}+\cdots\, .
\end{align*}
\pagebreak % TODO
丢掉$\gamma$和$\delta$项之积（可忽略的）高阶项，
边函数中两个$x$与$y$项之差的误差边界为
\sidenote{译者注：我猜测的推导是：
    先记$\hat{x}=\max\limits_i{|x_i|}$，
    $\hat{y}=\max\limits_i{|y_i|}$，以$e_0$为例，则有
    $e_0=(x_1y_2\pm\delta_{xy})\ominus(y_1x_2\pm\delta_{xy})=(x_1y_2-y_1x_2\pm2\delta_{xy})(1\pm\gamma_1)$。
    于是$\delta_e=\gamma_1|x_1y_2-y_1x_2|+2\delta_{xy}(1+\gamma_1)$，
    代入文中省略高阶项的$\delta_{xy}$并适当利用不等式缩放技巧，
    有$\delta_e\le\gamma_1\cdot2\hat{x}\hat{y}+2\delta_{xy}(1+\gamma_1)
        \approx2\gamma_1\hat{x}\hat{y}+2(\gamma_1\hat{x}\hat{y}+\delta_y\hat{x}+\delta_x\hat{y})(1+\gamma_1)
        =2((\gamma_1^2+2\gamma_1)\hat{x}\hat{y}+\delta_y\hat{x}+\delta_x\hat{y})+2\gamma_1(\delta_y\hat{x}+\delta_x\hat{y})$，
    再次忽略后一个括号的高阶项后只剩$2((\gamma_1^2+2\gamma_1)\hat{x}\hat{y}+\delta_y\hat{x}+\delta_x\hat{y})$。
    注意到$\displaystyle\gamma_1^2+2\gamma_1
        =\frac{\epsilon_{\mathrm{m}}^2}{(1-\epsilon_{\mathrm{m}})^2}+\frac{2\epsilon_{\mathrm{m}}}{1-\epsilon_{\mathrm{m}}}
        =\frac{2\epsilon_{\mathrm{m}}-\epsilon_{\mathrm{m}}^2}{(1-\epsilon_{\mathrm{m}})^2}
        <\frac{2\epsilon_{\mathrm{m}}}{1-2\epsilon_{\mathrm{m}}}=\gamma_2$，
    于是取$\delta_e$为$2(\gamma_2\hat{x}\hat{y}+\delta_y\hat{x}+\delta_x\hat{y})$。}
\begin{align*}
    \delta_e=2(\gamma_2\max_i{|x_i|}\max_i{|y_i|}+\delta_y\max_i{|x_i|}+\delta_x\max_i{|y_i|})\, .
\end{align*}

\begin{lstlisting}
`\initcode{Compute $\delta_e$ term for triangle t error bounds}{=}`
`\refvar{Float}{}` deltaE = 2 * (`\refvar{gamma}{}`(2) * maxXt * maxYt + deltaY * maxXt +
                    deltaX * maxYt);
\end{lstlisting}

再次通过取全部$e_i$项的最大误差来定界误差，
\refeq{3.18}中算得的$t$的分子值误差边界为
\sidenote{译者注：这里同样忽略了$\gamma$与$\delta$的乘积项。}
\begin{align*}
    \delta_t=3(\gamma_3\max\limits_i{|e_i|}\max\limits_i{|z_i|}+\delta_e\max\limits_i{|z_i|}+\delta_z\max\limits_i{|e_i|})\, .
\end{align*}

（被$e_i$之和归一化之前）算得的$t$值必须比该值大才能
被接收为一定具有正$t$值的有效相交。
\begin{lstlisting}
`\initcode{Compute $\delta_t$ term for triangle t error bounds and check t}{=}`
`\refvar{Float}{}` maxE = `\refvar{MaxComponent}{}`(`\refvar[Vector3::Abs]{Abs}{}`(`\refvar{Vector3f}{}`(e0, e1, e2)));
`\refvar{Float}{}` deltaT = 3 * (`\refvar{gamma}{}`(3) * maxE * maxZt + deltaE * maxZt +
                    deltaZ * maxE) * std::abs(invDet);
if (t <= deltaT)
    return false;
\end{lstlisting}

尽管为了效率我们看似没有尽力而是作出了许多计算更宽松边界的选择，
但实际上$t$中的误差边界非常小。
对于每个维度大约为$\pm10$的边界框中的常规场景，
我们在射线端点附近的$t$误差边界一般约为$10^{-7}$。

\subsection{讨论}\label{sub:讨论}
其他几何计算中（例如曲面位置的偏导数、插值纹理坐标等），
最小化并定界数值误差的重要性比起射线相交位置中的要小得多。
同样，在基于物理的渲染中涉及颜色和光源的计算一般不会出现关于舍入误差的问题；
它们涉及（通常有适度接近的数量级）正数乘积之和；
因此灾难性抵消不是常见问题。
而且，这是累积误差很小的足够少的项的和；
对它们所用的蒙特卡洛算法中固有的方差远大于计算它们时的任何浮点误差。

有趣的是，我们看到在用本节描述的方法替换
上一版pbrt的旧ad hoc方法以避免错误自相交后，
整体光线追踪执行时间大约增长了20\%
（相比之下，用双精度浮点渲染大约会增加30\%的渲染时间）。
分析表明求取误差边界的额外计算增加的时间很少；
这并不意外，因为我们的方法需要增加的计算是有限的——
大部分误差边界只是已经算得的项的绝对值的缩放之和。

该变慢情况的大部分实际是光线-物体相交测试量增大引起的。
相交测试量增加的原因首次由\citet[p.30]{Wächter_2008}确定；
当射线端点非常接近形状曲面时，与使用过度宽松的偏移量相比，
追踪触发光线时必须访问相交加速层级的更多节点。
因此，在射线端点附近要执行更多相交测试。
尽管这种性能下降是不幸的，
但它实际上是该方法更优精度的直接产物；
这是为更精确求解有效的邻近相交所付出的代价。