\section{习题}\label{sec:习题07}
\begin{enumerate}
      \item \circletwo 可以根据\refvar{RadicalInverse}{()}中的实现代码，
            为基2实现一个专门版本的\refvar{ScrambledRadicalInverse}{()}。
            确定怎样将随机数字排列映射为单个数位运算并实现该方法。
            比较算出的值和当前实现生成的值以确保你的方法是对的
            并通过编写一个小巧的基准程序来度量你的方法有多快。
      \item \circletwo 当前，每个样本的第三到五维是被时间和镜头样本用掉的，
            即便并非所有场景都需要这些样本值。因为样本向量中的更低维常比
            后面的分布得更好，所以这会造成不必要的图像质量下降。
            修改pbrt使得相机能表明其样本需求然后在需要样本来
            初始化\refvar{CameraSample}{}时利用该信息。
            别忘了更新\refvar[arrayStartDim]{GlobalSampler::arrayStartDim}{}的值。
            用\refvar{DirectLightingIntegrator}{}
            渲染图像并和当前实现的结果比较。你看到有改进吗？
            用不同采样器时结果有何区别？你怎样解释你所见到的各采样器间的任何区别？
      \item \label{sub:7.11.3}\circletwo 把\citet{Kensler2013Pixar}介绍
            改进的多重扰动采样方法实现为pbrt中的新
            \refvar{Sampler}{}。比较它和用\refvar{StratifiedSampler}{}、
            \refvar{HaltonSampler}{}以及\refvar{SobolSampler}{}渲染时
            的图像质量和渲染时间。
      \item \circletwo\citet{10.1007/3-540-31186-6_14}\sidenote{译者注：
                  在Springer获取的引用条目标注为2006年，
                  属于2004年的会议；原文则均标为2004年。}
            和\citet{10.1007/978-3-540-74496-2_12}\sidenote{译者注：
                  在Springer获取的引用条目标注为2008年，属于2006年的会议；
                  原文则均标为2006年。}描述了图像合成中\keyindex{一阶点阵}{rank-1 lattices}{}的应用。
            一阶点阵是另一种高效生成高质量低偏差样本点序列的方式。
            阅读他们的论文并基于该方法实现一个\refvar{Sampler}{}。
            比较它和pbrt中其他采样器的结果。
      \item \circletwo 用pbrt当前的\refvar{FilmTile}{}实现时，
            若重新渲染一幅图像，由于线程在后续运行中以不同顺序完成图块，
            图像中的像素值可能有轻微变化。例如一个像素最终值取自三个不同
            图像采样块中的样本，$v_1+v_2+v_3$，其值可能有时算作$(v_1+v_2)+v_3$
            而有时为$v_1+(v_2+v_3)$.由于浮点舍入，这两个值可能不同。
            尽管这些区别通常不成问题，但当想用自动化测试脚本验证对系统
            作出的无伤大雅的更改不会在渲染图像中实际引发任何区别时，
            它们就会造成灾难。修改\refvar[MergeFilmTile]{Film::MergeFilmTile}{()}使其
            以一致的顺序合并图块，从而让最终像素值不再被该不一致性干扰
            （例如你的实现可能缓存\refvar{FilmTile}{}并只在一个图块的
            上方和左侧相邻图块都已被合并时才合并它）。确保你的实现不引入
            任何意义上的性能倒退。度量因\refvar{FilmTile}{}生命期更长
            而新增的内存使用量；它和总内存使用量有什么关系？
      \item \circletwo 如\refsec{胶片与成像管道}中所述，
            方法\refvar[AddSplat]{Film::AddSplat}{()}没用滤波函数
            而是代之高效地用矩形滤波器把样本溅射到其最靠近的单个像素上。
            为了应用任意滤波器，必须规范化滤波器使得它在定义域上的积分为一；
            pbrt目前并不要求\refvar{Filter}{}满足该约束。
            修改\refvar{Film}{}构造函数中\refvar[Film::filterTable]{filterTable}{}的计算，
            使得制表函数规范化（别忘了在计算规范化因子时，
            表格只保存函数四分之一的范围）。然后修改方法\refvar{AddSplat}{()}的
            实现以使用该滤波器。研究其导致的执行时间和图像质量的区别。
      \item \circleone 修改pbrt以创建为每条相机光线存于\refvar{Film}{}的值
            都正比于计算该光线辐亮度所花时长的图像（一个1像素宽的矩形滤波器
            可能是对该习题最有用的滤波器）。用该技术渲染各种场景。
            得到的图像对于系统性能带来了怎样的启发？当你查看它们时
            你可能需要缩放像素值或取其对数来看到有意义的变化。
      \item \circletwo 辐射度量学中线性假设的一个优点是场景的最终图像和
            分别考虑每个光源分布的图像之和是一样的（假设使用不会
            截断像素辐亮度值的浮点图像块格式）。该性质意味着如果渲染器为
            每个光源创建单独的图像，可以写个交互式灯光设计工具让
            快速查看缩放场景中单个光源作用的影响而无需重新渲染成为可能。
            可代之以缩放一个光源的单独图像然后再对所有光源图像求和
            重新生成最终图像（该技术首先应用于\citet{10.1145/122718.122723}的
            歌剧灯光设计）。修改pbrt来为场景中的每个光源输出单独的图像，
            并写一个按该方式利用它们的交互式灯光设计工具。
      \item \circlethree \citet{10.1145/54852.378514}注意到
            有一簇重建滤波器同时用了函数值和它在该点的导数来进行
            比只知道函数值好得多的重建。此外，他们报告他们已为朗伯和
            冯氏反射模型\sidenote{译者注：原文Lambertian and Phong reflection models。}的
            屏幕空间导数推导出解析解，然而他们没有在其论文中包含这些表达式。
            研究基于导数的重建，扩展pbrt以支持该技术。
            因为给一般形状和BSDF模型的屏幕空间导数推导表达式可能很难，
            研究基于有限差分的近似即可。\refsec{采样与抗锯齿}射线差分背后
            基于该思想的技术可能对该尝试有成效。
      \item \circlethree \keyindex{基于图像的渲染}{image-based rendering}{render渲染}是
            使用一个场景一幅或多幅图像合成不同于原始视角的新视角图像的一组技术的总称。
            其中一种方法是\keyindex{光场渲染}{light field rendering}{render渲染}，
            即用一组来自密集间隔位置的图像\citep{10.1145/237170.237199,10.1145/237170.237200}。
            阅读这两篇关于光场的论文，并修改pbrt以直接生成场景的光场，
            而不需要渲染器运行多次，每次只针对一个相机位置。
            为此可能有必要编写专门的\refvar{Camera}{}、\refvar{Sampler}{}和\refvar{Film}{}。
            此外，编写一个交互式光场查看器来加载你的实现生成的光场并生成场景的新视角。
      \item \circlethree 比起只保存图像中的光谱值，常常更有用的是
            保存场景中在每个像素处可见的物体的额外信息。
            例如见\citet{10.1145/325334.325247}和\citet{10.1145/97879.97901}的SIGGRAPH论文。
            例如，如果保存每个像素处物体的3D位置、曲面法线以及BRDF，
            则移动光源后可高效地重新渲染场景\citep{10.1145/344779.344938}。
            或者，如果每个样本保存沿其相机光线可见的所有物体信息而不是只存第一个，
            则可以重新渲染移动视点后的新图像\citep{10.1145/280814.280882}。
            研究深帧缓冲区\sidenote{译者注：原文deep frame buffer，不确定该词翻译。}的表示
            和利用它的算法；扩展pbrt以支持创建像这样的图像，并开发对它们进行操作的工具。
      \item \circletwo 为图像重建实现中值滤波器：对于每个像素，保存
            滤波器范围内其周围所有样本的中值。该任务很复杂，因为事实上
            当前\refvar{Film}{}实现中的滤波器必须是\keyindex{线性的}{linear}{}——
            滤波函数值只取决于样本相对于像素位置的位置，样本值对滤波函数值没有影响。
            因为实现假设滤波器是线性的，且因为它在把样本值的贡献加到图像中后就不再保存了，
            所以实现中值滤波器要求一般化\refvar{Film}{}或开发新的\refvar{Film}{}实现。
            用像\refvar{PathIntegrator}{}那样搭配常规图像滤波器会有讨厌的图像噪声的积分器渲染图像。
            中值滤波器在减少噪声上有多成功？用中值滤波器有视觉缺陷吗？
            你能实现该方法而无需在计算最终像素值前保存所有图像样本值吗？
      \item \circletwo 中值滤波器的一种替代是丢弃像素滤波器区域中
            具有最小贡献的样本和具有最大贡献的样本。该方法更多使用采样期间收集的信息。
            实现该方法并比较它和中值滤波器的结果。
      \item \circlethree 实现\citeauthor{keller1998quasi}及其合作者
            介绍的非连续缓冲区\citep{keller1998quasi,10.2312:EGWR:EGWR02:015-024}。
            你可能需要修改\refvar{Integrator}{}的接口使得它们可以独自返回
            直接和间接照明贡献然后独立将其传给\refvar{Film}{}。
            渲染图像以展示其在用间接照明渲染图像时的高效性。
      \item \circlethree 实现近年一种自适应采样和重建技术，
            例如\citet{10.1145/1360612.1360632}、\citet{10.1145/1531326.1531399}、
            \citet{10.1145/1618452.1618486}或者\citet{10.1145/2641762}介绍的。
            比起只用高采样率的均匀采样它们生成同等质量图像要高效多少？
            对于无需自适应采样的简单场景它们如何影响运行时间？
      \item \circlethree 调研色调重建算法的当前研究
            （例如见\citet{reinhard2010high}、\citet{10.1145/2366145.2366220}），
            并实现其中一个或多个算法。对pbrt渲染的大量场景使用你的实现，
            并讨论比起查看无色调重建的图像你所见到的改进。
\end{enumerate}