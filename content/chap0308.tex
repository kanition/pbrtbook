\section{细分曲面}\label{sec:细分曲面}
\begin{remark}
    本节含有高级内容，第一次阅读时可以跳过。
\end{remark}

本章我们要定义的最后一个形状表示
实现了\keyindex{细分曲面}{subdivision surface}{surface\ 曲面}，
该表示尤其适合描述复杂光滑形状。
特定网格的细分曲面定义为将网格面反复细分为更小面
然后用旧顶点位置的加权组合求新顶点位置。

对于适当选择的细分规则，当细分步数趋于无穷时，
该过程会收敛到给出一个光滑的\keyindex{极限曲面}{limit surface}{surface\ 曲面}。
实践中，只需少量级别的细分通常就足以得到极限曲面的良好近似。
\reffig{3.24}展示了一个细分的简单例子，
其中四面体被细分了零次、一次、两次和六次。
\begin{figure}[htbp]
    \centering\includegraphics[width=\linewidth]{chap03/tetsubdiv.png}
    \caption{四面体的细分。从左到右使用了零步、一步、两步和六步细分
        （在零级时，顶点只是移动到极限曲面上）。
        随着细分得越来越多，网格逼近极限曲面，即原始网格描述的光滑曲面。
        随着执行更多级别的细分，注意高光如何变得更加准确、轮廓边缘如何变得更加平滑。}
    \label{fig:3.24}
\end{figure}

\reffig{3.25}展示了对Killeroo\sidenote{译者注：猜测此名字与一澳大利亚漫画中的袋鼠角色名有关。}模型应用细分的效果；
上面是原始控制网格，下面是控制网格表示的细分曲面。
\begin{figure}[htbp]
    \centering
    \subfloat[控制网格]{\includegraphics[width=\linewidth]{chap03/killeroo-control.png}\label{fig:3.25.1}}\\
    \subfloat[细分网格]{\includegraphics[width=\linewidth]{chap03/killeroo-subdivided.png}\label{fig:3.25.2}}
    \caption{对Killeroo模型应用细分。(1)控制网格描述了(2)结果细分曲面。
        细分非常适合建模这样的形状，因为它能通过细化控制网格轻松添加局部细节，
        对最终曲面没有拓扑结构限制。（模型由headus/Rezard提供。）}
    \label{fig:3.25}
\end{figure}


因为在曲面的多边形和基于样条的表示方面有一些重要优势，
细分曲面近年来得到广泛运用，尽管它在20世纪70年代就被发明了。
细分的优势包括：
\begin{itemize}
    \item 细分曲面是平滑的，而多边形网格与之相反，无论建模得多细致，靠近观察会有小面。
    \item 建模系统中现有的多数基本结构可以重定向到细分。
          建模多边形网格的经典技术工具箱可以应用到建模细分控制网格上。
    \item 细分曲面非常适合描述有复杂拓扑结构的物体，
          因为它们以任意（\keyindex{流形}{manifold}{}）拓扑结构的控制网格为起点。
          参数化曲面模型一般不能很好地处理复杂拓扑结构。
    \item 细分方法常常是基于样条的曲面表示的推广，
          所以样条曲面常常可以由通用细分曲面渲染器运行。
    \item 通过简单地对控制网格的适当部分添加面，它能轻松对细分曲面局部区域添加细节。
          用样条表示则要困难得多。
\end{itemize}
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Subdivrefinement.tex}
    \caption{Loop细分的基本细化过程。（左）细分之前的控制网格。
        （右）一步细分后的新网格。通过划分每条边并连接新顶点和新边，
        网格的每个三角形面都被细分为四个新面。}
    \label{fig:3.26}
\end{figure}

这里，我们将介绍\keyindex{Loop细分曲面}{Loop subdivision surface}{surface\ 曲面}
\footnote{以所用的细分规则发明者Charles Loop的名字命名。}的一种实现。
Loop细分规则基于控制网格中的三角形面；
开始时具有超过三个顶点的面被三角剖分。
在每步细分中，所有面分为四个子面（\reffig{3.26}）。
沿原始网格的所有边添加新顶点，
使用相邻顶点的加权平均计算位置。
而且，每个原始顶点的位置也用其位置和新邻居位置的加权平均更新。
这里的实现使用的权值基于\citet{10.1145/192161.192233}开发的
对Loop方法的改进。
我们这里不涵盖关于怎样推导出这些权值的讨论。
虽然需要精妙的数学推导证明它们确实满足了这一点，
但必须谨慎选择它们以保证极限曲面确实有特定期望的光滑性质。

细分曲面不是在pbrt中实现为\refvar{Shape}{}，
而是由函数\refvar{LoopSubdivide}{()}推广，
它将细分规则应用到一系列顶点和顶点索引表示的网格上
并返回表示最终细分网格的\refvar{Triangle}{}向量。
\begin{lstlisting}
`\initcode{LoopSubdiv Function Definitions}{=}\initnext{LoopSubdivFunctionDefinitions}`
std::vector<std::shared_ptr<`\refvar{Shape}{}`>> `\initvar{LoopSubdivide}{}`(
        const `\refvar{Transform}{}` *ObjectToWorld, const `\refvar{Transform}{}` *WorldToObject,
        bool reverseOrientation, int nLevels, int nIndices,
        const int *vertexIndices, int nVertices, const `\refvar{Point3f}{}` *p) {
    std::vector<`\refvar{SDVertex}{}` *> vertices;
    std::vector<`\refvar{SDFace}{}` *> faces;
    `\refcode{Allocate LoopSubdiv vertices and faces}{}`
    `\refcode{Set face to vertex pointers}{}`
    `\refcode{Set neighbor pointers in faces}{}`
    `\refcode{Finish vertex initialization}{}`
    `\refcode{Refine subdivision mesh into triangles}{}`
}
\end{lstlisting}

\subsection{网格表示}\label{sub:网格表示}
\refvar{LoopSubdivide}{()}的参数用和\refvar{TriangleMesh}{}构造函数中
一样的格式指定了三角网格（\refsec{三角形网格}）：
每个面由三个整数顶点索引描述，
给出面的三个顶点在顶点数组{\ttfamily p}中的偏移量。
我们需要处理该数据以决定哪些面彼此相邻，
哪些面和哪些顶点相邻
\sidenote{译者注：文中“相邻”是一个宽泛的概念。
    面与面“相邻”指两个面有公共边；
    面与点“相邻”指该点是该面的顶点；
    面与边“相邻”指该边是该面的一条边。
    边与点“相邻”指该点是该边的端点……下文同。}等等，以实现细分算法。

我们将很快定义结构体\refvar{SDVertex}{}和\refvar{SDFace}{}，
它们存有细分网格中顶点和面的数据。
\refvar{LoopSubdivide}{()}从为网格中的每个顶点分配
一个\refvar{SDVertex}{}实例以及为每个面分配\refvar{SDFace}{}开始。
现在，它们几乎都没有初始化。
\begin{lstlisting}
`\initcode{Allocate LoopSubdiv vertices and faces}{=}`
std::unique_ptr<`\refvar{SDVertex}{}`[]> verts(new `\refvar{SDVertex}{}`[nVertices]);
for (int i = 0; i < nVertices; ++i) {
    verts[i] = `\refvar{SDVertex}{}`(p[i]);
    vertices.push_back(&verts[i]);
}
int nFaces = nIndices / 3;
std::unique_ptr<`\refvar{SDFace}{}`[]> fs(new `\refvar{SDFace}{}`[nFaces]);
for (int i = 0; i < nFaces; ++i)
    faces.push_back(&fs[i]);
\end{lstlisting}

Loop细分方案像多数其他细分方案那样，
假设控制网格是\keyindex{流形}{manifold}{}——
共享任意给定边的面不超过两个。
这样的网格可能是闭合的或开放的：\keyindex{闭合网格}{closed mesh}{mesh\ 网格}没有
边界且所有面的每条边都有邻接面。\keyindex{开放网格}{open mesh}{mesh\ 网格}有
一些面没有全部三个邻居。
这里的实现同时支持闭合和开放网格。

在三角网格内部，大多数顶点和六个面相邻且
有六个相邻顶点通过边直接与其相连。
在开放网格的边界上，大多数顶点与三个面和四个顶点相邻。
与一个顶点直接相邻的顶点数称为该顶点的\keyindex{价}{valence}{}。
价不是六的内部顶点或价不是四的边界顶点
称为\keyindex{非凡顶点}{extraordinary vertex}{vertex\ 顶点}；
否则称为\keyindex{正则的}{regular}{}\footnote{这些术语常用于建模文献中，
    尽管“irregular”对“regular”或者“extraordinary”对“ordinary”更符合直觉。}。
Loop细分曲面在除非凡顶点外的任意处都是光滑的。

每个\refvar{SDVertex}{}存储其位置\refvar[SDVertex::p]{p}{}、
表示它是正则还是非凡顶点的布尔量以及
记录它是否位于网格边界上的布尔量。
它也存有指向任意与之相邻的面的指针；
该指针给出了寻找其所有相邻面的起点。
最后如果有的话，有一个指针为下一级的细分存储相应的\refvar{SDVertex}{}。
\begin{lstlisting}
`\initcode{LoopSubdiv Local Structures}{=}\initnext{LoopSubdivLocalStructures}`
struct `\initvar{SDVertex}{}` {
    `\refcode{SDVertex Constructor}{}`
    `\refcode{SDVertex Methods}{}`
    `\refvar{Point3f}{}` `\initvar[SDVertex::p]{p}{}`;
    `\refvar{SDFace}{}` *`\initvar{startFace}{}` = nullptr;
    `\refvar{SDVertex}{}` *`\initvar{child}{}` = nullptr;
    bool `\initvar{regular}{}` = false, `\initvar[SDVertex::boundary]{boundary}{}` = false;
};
\end{lstlisting}
\begin{lstlisting}
`\initcode{SDVertex Constructor}{=}`
`\refvar{SDVertex}{}`(const `\refvar{Point3f}{}` &p = `\refvar{Point3f}{}`(0, 0, 0)) : `\refvar[SDVertex::p]{p}{}`(p) { }
\end{lstlisting}

结构体\refvar{SDFace}{}存有最多关于网格的拓扑信息的地方。
因为所有面都是三角形，面总是存有指向其三个顶点的指针以及
指向其三条边相邻的面的指针。
如果面在开放网格边缘上则相应的相邻面指针为{\ttfamily nullptr}。

相邻面指针索引是，如果我们把从{\ttfamily\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边
标为第{\ttfamily i}边，则该边的相邻面存于{\ttfamily\refvar[SDFace::f]{f}{}[i]}（\reffig{3.27}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivvertfacepointers.eps}
    \caption{每个三角形面存有三个指向\protect\refvar{SDVertex}{}对象的
    指针{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}以及三个
    指向相邻面的指针{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}。
    相邻面索引使用的约定是第{\ttfamily i}边是
    从{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\protect\refvar[SDFace::v]{v}{}[(i+1)\%3]}的边，
    且第{\ttfamily i}边的邻居在{\ttfamily\protect\refvar[SDFace::f]{f}{}[i]}中。}
    \label{fig:3.27}
\end{figure}

\begin{lstlisting}
`\refcode{LoopSubdiv Local Structures}{+=}\lastnext{LoopSubdivLocalStructures}`
struct `\initvar{SDFace}{}` {
    `\refcode{SDFace Constructor}{}`
    `\refcode{SDFace Methods}{}`
    `\refvar{SDVertex}{}` *`\initvar[SDFace::v]{v}{}`[3];
    `\refvar{SDFace}{}` *`\initvar[SDFace::f]{f}{}`[3];
    `\refvar{SDFace}{}` *`\initvar[SDFace::children]{children}{}`[4];
};
\end{lstlisting}

\refvar{SDFace}{}构造函数很简单——它简单地把这些不同的指针设置为{\ttfamily nullptr}——
所以这里不再展示。

为简化\refvar{SDFace}{}的数据结构导航，
我们提供宏使得决定特定索引前后的顶点和面索引更容易。
这些宏添加适合的偏移量并计算模三结果以负责循环。
\begin{lstlisting}
`\initcode{LoopSubdiv Macros}{=}`
#define `\initvar{NEXT}{}`(i) (((i) + 1) % 3)
#define `\initvar{PREV}{}`(i) (((i) + 2) % 3)
\end{lstlisting}

除了需要流形网格外，细分代码希望用户指定的控制网格
是\keyindex{相容次序}{consistently ordered}{}的——
网格中每条\keyindex{有向边}{directed edge}{edge\ 边}只出现一次。
两个面的公共边须由每个面指定为不同方向。
考虑两个顶点$\bm v_0$和$\bm v_1$与连接它们的边。
我们希望拥有该边的三角形面指定其三个顶点时$\bm v_0$在$\bm v_1$之前，
另一个面指定顶点时$\bm v_1$在$\bm v_0$之前（\reffig{3.28}）。
\keyindex{默比乌斯带}{Möbius strip}{}是无法相容次序的曲面例子，
但渲染中几乎不会遇到这样的曲面，所以实践中该限制没问题。
然而不能创建相容次序网格的程序给出的没构建好的网格数据可能会造成问题。
\begin{figure}[htbp]
    \centering\input{Pictures/chap03/Subdivfaceorientation.tex}
    \caption{输入网格中的所有面必须指定为让每条公共边在每个方向最多出现一次。
        这里，从$\bm v_0$到$\bm v_1$的边被一个面从$\bm v_0$到$\bm v_1$穿过
        而被另一个面从$\bm v_1$到$\bm v_0$穿过。
        另一个看待方式是考虑面朝向：从网格外边观察时，
        所有面的顶点应该统一地以顺时针或逆时针顺序给出。}
    \label{fig:3.28}
\end{figure}

有了关于输入数据的该假设，\refvar{LoopSubdivide}{()}现在
可以初始化网格的拓扑数据结构了。
它首先遍历所有面并设置它们的指针\refvar[SDFace::v]{v}{}指向它们的三个顶点。
它还设置每个顶点的指针\refvar[startFace]{SDVertex::startFace}{}指向
该顶点相邻面中的一个。具体使用哪一个相邻面并不重要，
所以每次遇到该顶点关联的另一个面时，该实现就重设它，
这条保证所有顶点在遍历完成前都有非空的面指针。
\begin{lstlisting}
`\initcode{Set face to vertex pointers}{=}`
const int *vp = vertexIndices;
for (int i = 0; i < nFaces; ++i, vp += 3) {
    `\refvar{SDFace}{}` *f = faces[i];
    for (int j = 0; j < 3; ++j) {
        `\refvar{SDVertex}{}` *v = vertices[vp[j]];
        f->`\refvar[SDFace::v]{v}{}`[j] = v;
        v->`\refvar{startFace}{}` = f;
    }
}
\end{lstlisting}

现在有必要将每个面的\refvar[SDFace::f]{f}{}指针设置为指向其相邻面。
这有些棘手，因为传入
\refvar{LoopSubdivide}{()}的数据并不直接指定面的相邻信息。
这里的实现遍历面并为其三条边的每一条都创建\refvar{SDEdge}{}对象。
当遇到另一个面共享同一边时，它就更新两个面的相邻指针。
\begin{lstlisting}
`\refcode{LoopSubdiv Local Structures}{+=}\lastcode{LoopSubdivLocalStructures}`
struct `\initvar{SDEdge}{}` {
    `\refcode{SDEdge Constructor}{}`
    `\refcode{SDEdge Comparison Function}{}`
    `\refvar{SDVertex}{}` *`\initvar[SDEdge::v]{v}{}`[2];
    `\refvar{SDFace}{}` *`\initvar[SDEdge::f]{f}{}`[2];
    int `\initvar{f0edgeNum}{}`;
};
\end{lstlisting}

\refvar{SDEdge}{}构造函数接收指向边的两端顶点的指针。
它对指针排序使得{\ttfamily\refvar[SDEdge::v]{v}{}[0]}是
排在内存中最前面的那个。这段代码可能看起来很奇怪，
但它简单依赖于这样的事实即C++中的指针是可以像整数那样高效操作的数字
\footnote{尽管是分段架构。}而边的顶点顺序是任意的。
基于其指针地址排列这两个顶点保证了边$(\bm v_a,\bm v_b)$可以
被正确认作和边$(\bm v_b,\bm v_a)$相同，而不管提供的顶点顺序是什么。
\begin{lstlisting}
`\initcode{SDEdge Constructor}{=}`
`\refvar{SDEdge}{}`(`\refvar{SDVertex}{}` *v0 = nullptr, `\refvar{SDVertex}{}` *v1 = nullptr) {
    `\refvar[SDEdge::v]{v}{}`[0] = std::min(v0, v1);
    `\refvar[SDEdge::v]{v}{}`[1] = std::max(v0, v1);
    `\refvar[SDEdge::f]{f}{}`[0] = `\refvar[SDEdge::f]{f}{}`[1] = nullptr;
    `\refvar{f0edgeNum}{}` = -1;
}
\end{lstlisting}

该类还定义了\refvar{SDEdge}{}对象的排序操作
这样它们就能存于其他依赖良好顺序定义的数据结构。
\begin{lstlisting}
`\initcode{SDEdge Comparison Function}{=}`
bool operator<(const `\refvar{SDEdge}{}` &e2) const {
    if (`\refvar[SDEdge::v]{v}{}`[0] == e2.`\refvar[SDEdge::v]{v}{}`[0]) return `\refvar[SDEdge::v]{v}{}`[1] < e2.`\refvar[SDEdge::v]{v}{}`[1];
    return `\refvar[SDEdge::v]{v}{}`[0] < e2.`\refvar[SDEdge::v]{v}{}`[0];
}
\end{lstlisting}

现在函数\refvar{LoopSubdivide}{()}可以开始工作了，
遍历所有面的边并随之更新相邻指针。
它用{\ttfamily set}存储目前只有一个相邻面的边。
{\ttfamily set}让在$O(\log{n})$时间内搜索特定边成为可能。
\begin{lstlisting}
`\initcode{Set neighbor pointers in faces}{=}`
std::set<`\refvar{SDEdge}{}`> edges;
for (int i = 0; i < nFaces; ++i) {
    `\refvar{SDFace}{}` *f = faces[i];
    for (int edgeNum = 0; edgeNum < 3; ++edgeNum) {
        `\refcode{Update neighbor pointer for edgeNum}{}`
    }
}
\end{lstlisting}

对于每个面中的每条边，循环体创建一个边对象并检查之前是否已经见过同样的边。
如果是，它就初始化共享该边的两个面的相邻指针。
如果否，它就将该边添加到边的集合中。
该边两端顶点的索引{\ttfamily v0}和{\ttfamily v1}，
分别等于边的索引和边的索引加一。
\begin{lstlisting}
`\initcode{Update neighbor pointer for edgeNum}{=}`
int v0 = edgeNum, v1 = `\refvar{NEXT}{}`(edgeNum);
`\refvar{SDEdge}{}` e(f->`\refvar[SDFace::v]{v}{}`[v0], f->`\refvar[SDFace::v]{v}{}`[v1]);
if (edges.find(e) == edges.end()) {
    `\refcode{Handle new edge}{}`
} else {
    `\refcode{Handle previously seen edge}{}`
}
\end{lstlisting}

给定之前没遇到的边，当前的面的指针存储于边对象的成员{\ttfamily\refvar[SDEdge::f]{f}{}[0]}中。
因为假设输入网格是流形，所以最多还有另一个面共享这条边。
当发现该面时，可以用它初始化相邻面的域。
在当前的面中存储该边的号码能让相邻面初始化其相应相邻边的指针。
\begin{lstlisting}
`\initcode{Handle new edge}{=}`
e.`\refvar[SDEdge::f]{f}{}`[0] = f;
e.`\refvar{f0edgeNum}{}` = edgeNum;
edges.insert(e);
\end{lstlisting}

当找到该边上的第二个面时，两个面都设置相邻指针。
然后从边的集合中移除该边，因为没有边可以被两个以上的面共享。
\begin{lstlisting}
`\initcode{Handle previously seen edge}{=}`
e = *edges.find(e);
e.`\refvar[SDEdge::f]{f}{}`[0]->`\refvar[SDFace::f]{f}{}`[e.`\refvar{f0edgeNum}{}`] = f;
f->`\refvar[SDFace::f]{f}{}`[edgeNum] = e.`\refvar[SDEdge::f]{f}{}`[0];
edges.erase(e);
\end{lstlisting}

现在所有面都有合适的相邻指针，
可以设置每个顶点中的标志\refvar[SDVertex::boundary]{boundary}{}和
\refvar{regular}{}了。为了确定顶点是否是边界顶点，我们将定义围绕顶点的面顺序（\reffig{3.29}）。
对于面{\ttfamily f}上的顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}，
我们定义顶点的\emph{下一面}是邻接从{\ttfamily\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\refvar[SDFace::v]{v}{}[\refvar{NEXT}{}(i)]}的边的面，
\emph{上一面}是邻接从{\ttfamily\refvar[SDFace::v]{v}{}[\refvar{PREV}{}(i)]}到{\ttfamily\refvar[SDFace::v]{v}{}[i]}的边的面。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.4\linewidth]{chap03/Subdivprevnextface.eps}
    \caption{给定顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}和附带的面{\ttfamily f}，
    我们定义\emph{下一面}为与{\ttfamily f}通过
    从{\ttfamily\protect\refvar[SDFace::v]{v}{}[i]}到{\ttfamily\protect\refvar[SDFace::v]{v}{}[\protect\refvar{NEXT}{}(i)]}的边邻接的面。
    上一面的定义类似。}
    \label{fig:3.29}
\end{figure}

通过依次转到围绕\refvar[SDFace::v]{v}{}的下一面，
我们可以遍历与之相邻的面
\sidenote{译者注：思考一下，相容次序为这种遍历提供了什么便利？}。
如果我们最终回到出发的面，则我们位于内部顶点上；
如果我们遇到一条边的相邻指针是{\ttfamily nullptr}，
则我们位于边界顶点上（\reffig{3.30}）。
一旦初始化例程确定这是否是边界顶点，
它就计算顶点的价，如果是价为6的内部顶点或价为4的边界顶点，
就置位标志\refvar{regular}{}；否则这是个非凡顶点。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.5\linewidth]{chap03/Subdivdetermineboundary.eps}
    \caption{我们可以通过从相邻面\protect\refvar{startFace}{}开始
        并跟随围绕该顶点的下一面指针来确定一个顶点是否是边界顶点。
        如果我们遇到一个没有下一相邻面的面，则该顶点在边界上。
        如果我们回到\protect\refvar{startFace}{}，则它是内部顶点。}
    \label{fig:3.30}
\end{figure}

\begin{lstlisting}
`\initcode{Finish vertex initialization}{=}`
for (int i = 0; i < nVertices; ++i) {
    `\refvar{SDVertex}{}` *v = vertices[i];
    `\refvar{SDFace}{}` *f = v->`\refvar{startFace}{}`;
    do {
        f = f->`\refvar{nextFace}{}`(v);
    } while (f && f != v->`\refvar{startFace}{}`);
    v->`\refvar[SDVertex::boundary]{boundary}{}` = (f == nullptr);
    if (!v->`\refvar[SDVertex::boundary]{boundary}{}` && v->`\refvar{valence}{}`() == 6)
        v->`\refvar{regular}{}` = true;
    else if (v->`\refvar[SDVertex::boundary]{boundary}{}` && v->`\refvar{valence}{}`() == 4)
        v->`\refvar{regular}{}` = true;
    else
        v->`\refvar{regular}{}` = false;
}
\end{lstlisting}

因为经常需要顶点的价，所以我们提供方法\refvar[valence]{SDVertex::valence}{()}
\sidenote{译者注：我认为该方法可能不适合处理一些极其特殊罕见的情况，
    但确实够用了，详见\url{https://github.com/mmp/pbrt-v4/issues/143}。}。
\begin{lstlisting}
`\initcode{LoopSubdiv Inline Functions}{=}\initnext{LoopSubdivInlineFunctions}`
inline int `\refvar{SDVertex}{}`::`\initvar{valence}{}`() {
    `\refvar{SDFace}{}` *f = `\refvar{startFace}{}`;
    if (!`\refvar[SDVertex::boundary]{boundary}{}`) {
        `\refcode{Compute valence of interior vertex}{}`
    } else {
        `\refcode{Compute valence of boundary vertex}{}`
    }
}
\end{lstlisting}

为了计算非边界顶点的价，该方法跟随每个面围绕该顶点的相邻指针
开始计算相邻面的数量，直到它回到出发的面。
价等于访问的面的数量。
\begin{lstlisting}
`\initcode{Compute valence of interior vertex}{=}`
int nf = 1;
while ((f = f->`\refvar{nextFace}{}`(this)) != `\refvar{startFace}{}`)
    ++nf;
return nf;
\end{lstlisting}

对于边界顶点我们可以用相同的方法，但这种情况下价比相邻面的数量多一。
这里遍历相邻面稍微更复杂些：它跟随围绕该顶点的下一面指针直到遇到边界，计算见过的面的数量。
然后它再次从\refvar{startFace}{}开始并跟随上一面指针直到在另一方向遇到边界。
\begin{lstlisting}
`\initcode{Compute valence of boundary vertex}{=}`
int nf = 1;
while ((f = f->`\refvar{nextFace}{}`(this)) != nullptr)
    ++nf;
f = `\refvar{startFace}{}`;
while ((f = f->`\refvar{prevFace}{}`(this)) != nullptr)
    ++nf;
return nf + 1;
\end{lstlisting}

\refvar[vnum]{SDFace::vnum}{()}是查找给定顶点指针的索引的实用函数。
传入一个不属于当前的面的顶点指针是致命错误——
这种情况表明细分代码中有bug。
\begin{lstlisting}
`\initcode{SDFace Methods}{=}\initnext{SDFaceMethods}`
int `\initvar{vnum}{}`(`\refvar{SDVertex}{}` *vert) const {
    for (int i = 0; i < 3; ++i)
        if (`\refvar[SDFace::v]{v}{}`[i] == vert) return i;
    `\refvar{Severe}{}`("Basic logic error in SDFace::vnum()");
    return -1;
}
\end{lstlisting}

因为面{\ttfamily f}上顶点{\ttfamily\refvar[SDFace::v]{v}{}[i]}的
下一面在第i边上（回想\reffig{3.27}中相邻边指针的映射），
给定实用函数\refvar{vnum}{()}提供的顶点索引{\ttfamily i}，
我们可轻松找出合适的相邻面指针。
上一面邻接从{\ttfamily\refvar{PREV}{}(i)}到{\ttfamily i}的边，
所以对于上一面该方法返回{\ttfamily \refvar[SDFace::f]{f}{}[\refvar{PREV}{}(i)]}。
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDFace}{}` *`\initvar{nextFace}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::f]{f}{}`[`\refvar{vnum}{}`(vert)];
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDFace}{}` *`\initvar{prevFace}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::f]{f}{}`[`\refvar{PREV}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}

能够从任意顶点开始获取围绕一个面的上一个和下一个顶点也很有用。
方法\refvar[nextVert]{SDFace::nextVert}{()}和\refvar[prevVert]{SDFace::prevVert}{()}就是干这个的（\reffig{3.31}）。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivprevnextvert.eps}
    \caption{给定顶点{\ttfamily v}和面{\ttfamily f}，
    方法{\ttfamily f->\protect\refvar{prevVert}{}(v)}返回
    从{\ttfamily v}起绕该面的上一个顶点，
    而{\ttfamily f->\protect\refvar{nextVert}{}(v)}返回下一个顶点，
    其中“下一个”和“上一个”由定义该面时的顶点原始顺序定义。}
    \label{fig:3.31}
\end{figure}

\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDVertex}{}` *`\initvar{nextVert}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::v]{v}{}`[`\refvar{NEXT}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastnext{SDFaceMethods}`
`\refvar{SDVertex}{}` *`\initvar{prevVert}{}`(`\refvar{SDVertex}{}` *vert) {
    return `\refvar[SDFace::v]{v}{}`[`\refvar{PREV}{}`(`\refvar{vnum}{}`(vert))];
}
\end{lstlisting}

\subsection{细分}\label{sub:细分}
现在我们可以展示怎样用修改后的Loop规则进行细分了。
这里的实现施加固定次数的细分来为渲染生成三角网格；
本章末习题7讨论了自适应细分，每个原始面都被细分足够的次数
使得从特定视点观察的结果是光滑的，而不是仅用固定层级数的细分，
否则一些区域可能过细分而同时另一些则欠细分。

代码片\refcode{Refine subdivision mesh into triangles}{}反复
对网格运用细分规则，每次都生成一个新网格用作下一步的输入。
每次细分步骤后，数组{\ttfamily f}和{\ttfamily v}都更新为
指向来自刚完成的细分层级的面和顶点。
当细分完成时，便返回曲面的三角网格表示。

类\refvar{MemoryArena}{}的实例用于在该过程中分配临时存储。
该类定义于\refsub{基于Arena的分配}，提供了快速的自定义内存分配方法，
当它离开作用域时会自动释放内存。

\begin{lstlisting}
`\initcode{Refine subdivision mesh into triangles}{=}`
std::vector<`\refvar{SDFace}{}` *> f = faces;
std::vector<`\refvar{SDVertex}{}` *> v = vertices;
`\refvar{MemoryArena}{}` arena;
for (int i = 0; i < nLevels; ++i) {
    `\refcode{Update f and v for next level of subdivision}{}`
}
`\refcode{Push vertices to limit surface}{}`
`\refcode{Compute vertex tangents on limit surface}{}`
`\refcode{Create triangle mesh from subdivision mesh}{}`
\end{lstlisting}

细分步骤主循环的过程如下：它创建{\ttfamily vector}来存储
当前细分层级的顶点和面，并继续计算新顶点位置，更新细化网格的拓扑表示。
\reffig{3.32}展示了网格中面的基本细化规则。
每个面被分为四个子面，第{\ttfamily i}个子面
与输入面的第{\ttfamily i}个顶点相邻且最后一个面位于中心。
然后沿原始面的分割边计算三个新顶点。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.6\linewidth]{chap03/Subdivrefinementnaming.eps}
    \caption{单个三角面的基本细分。创建和排序四个子面，第{\ttfamily i}个子面
    与原始面的第{\ttfamily i}个顶点相邻且第四个子面位于细分面的中心。
    需要计算三条边上的顶点；它们的编号满足第{\ttfamily i}个边上顶点在原始面的第{\ttfamily i}条边上。}
    \label{fig:3.32}
\end{figure}

\begin{lstlisting}
`\initcode{Update f and v for next level of subdivision}{=}`
std::vector<`\refvar{SDFace}{}` *> newFaces;
std::vector<`\refvar{SDVertex}{}` *> newVertices;
`\refcode{Allocate next level of children in mesh tree}{}`
`\refcode{Update vertex positions and create new edge vertices}{}`
`\refcode{Update new mesh topology}{}`
`\refcode{Prepare for next level of subdivision}{}`
\end{lstlisting}

首先，为已经出现在输入网格中的顶点的更新值分配存储。该方法还为子面分配存储。
但除了设置顶点的标志\refvar{regular}{}和\refvar[SDVertex::boundary]{boundary}{}外，
它还没对新顶点和面做任何初始化，因为细分让边界顶点仍在边界上，
内部顶点仍在内部，且不改变网格中顶点的价。
\begin{lstlisting}
`\initcode{Allocate next level of children in mesh tree}{=}`
for (`\refvar{SDVertex}{}` *vertex : v) {
    vertex->`\refvar{child}{}` = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{SDVertex}{}`>();
    vertex->`\refvar{child}{}`->`\refvar{regular}{}` = vertex->`\refvar{regular}{}`;
    vertex->`\refvar{child}{}`->`\refvar[SDVertex::boundary]{boundary}{}` = vertex->`\refvar[SDVertex::boundary]{boundary}{}`;
    newVertices.push_back(vertex->`\refvar{child}{}`);
}
for (`\refvar{SDFace}{}` *face : f) {
    for (int k = 0; k < 4; ++k) {
        face->`\refvar[SDFace::children]{children}{}`[k] = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{SDFace}{}`>();
        newFaces.push_back(face->`\refvar[SDFace::children]{children}{}`[k]);
    }
}
\end{lstlisting}

\subsubsection*{计算新顶点的位置}
在担心细分网格的拓扑初始化之前，细化方法先为网格中的所有顶点计算位置。
首先，它考虑所有已经出现于网格中的顶点的更新位置计算问题；
这些顶点称为\keyindex{偶顶点}{even vertex}{vertex\ 顶点}。
然后它计算分割边上的新顶点，称为\keyindex{奇顶点}{odd vertex}{vertex\ 顶点}。
\begin{lstlisting}
`\initcode{Update vertex positions and create new edge vertices}{=}`
`\refcode{Update vertex positions for even vertices}{}`
`\refcode{Compute new odd edge vertices}{}`
\end{lstlisting}

对于偶顶点的每种不同类型——正则与非凡、边界与内部，
计算更新位置使用的技术不同。这给出了四种要处理的情况。
\begin{lstlisting}
`\initcode{Update vertex positions for even vertices}{=}`
for (`\refvar{SDVertex}{}` *vertex : v) {
    if (!vertex->`\refvar[SDVertex::boundary]{boundary}{}`) {
        `\refcode{Apply one-ring rule for even vertex}{}`
    } else {
        `\refcode{Apply boundary rule for even vertex}{}`
    }
}
\end{lstlisting}

对于内部顶点的两种类型，我们取每个顶点的相邻顶点集合
（称为绕它的\keyindex{一环}{one-ring}{}，反映了它是一圈邻居的事实）
并用权重$\beta$为每个邻居顶点赋权（\reffig{3.33}）。
我们正在更新的中心顶点赋权为$1-n\beta$，其中$n$为该顶点的价。
因此，顶点$\bm v$对应的新顶点$\bm v'$为
\begin{align*}
    \bm v'=(1-n\beta)\bm v+\sum\limits_{i=1}^{N}{\beta \bm v_i}\, .
\end{align*}

该公式确保权重之和为一，保证了Loop细分曲面的凸包性质，
确保最终网格在控制网格的凸包内。
正在更新的顶点位置只受附近顶点的影响；
这称为\keyindex{局部支撑}{local support}{}。
Loop细分尤其高效，因为其细分规则均有该性质。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.3\linewidth]{chap03/Subdivoneringweighting.eps}
    \caption{顶点$\bm v$的新顶点$\bm v'$通过用权重$\beta$对相邻顶点$\bm v_i$赋权、
        用$(1-n\beta)$对$\bm v$赋权计算得到，其中$n$为$\bm v$的价。
        相邻顶点$\bm v_i$统称为绕$\bm v$的\emph{一环}。}
    \label{fig:3.33}
\end{figure}

该步骤所用的指定权重$\beta$是细分方法的关键组成，
必须仔细选取以保证极限曲面的光滑性以及其他所需的性质
\footnote{再次见本节开头和“扩展阅读”一节引用的文献
    了解关于如何推导出$\beta$等值的信息。}。
下面的函数\refvar{beta}{()}基于顶点的价计算能够保证光滑性的$\beta$值。
对于正则内部顶点，\refvar{beta}{()}返回$\displaystyle\frac{1}{16}$.
因为这是常见情况，所以实现直接用$\displaystyle\frac{1}{16}$而不是每次都调用\refvar{beta}{()}。
\begin{lstlisting}
`\initcode{Apply one-ring rule for even vertex}{=}`
if (vertex->`\refvar{regular}{}`)
    vertex->`\refvar{child}{}`->`\refvar[SDVertex::p]{p}{}` = `\refvar{weightOneRing}{}`(vertex, 1.f / 16.f);
else
    vertex->`\refvar{child}{}`->`\refvar[SDVertex::p]{p}{}` = `\refvar{weightOneRing}{}`(vertex, `\refvar{beta}{}`(vertex->`\refvar{valence}{}`()));
\end{lstlisting}
\begin{lstlisting}
`\refcode{LoopSubdiv Inline Functions}{+=}\lastnext{LoopSubdivInlineFunctions}`
inline `\refvar{Float}{}` `\initvar{beta}{}`(int valence) {
    if (valence == 3) return 3.f / 16.f;
    else return 3.f / (8.f * valence);
}
\end{lstlisting}

函数\refvar{weightOneRing}{()}遍历一环相邻顶点并用给定权重计算新顶点位置。
它用后面定义的方法\refvar[oneRing]{SDVertex::oneRing}{()}
返回绕顶点{\ttfamily vert}的顶点位置。
\begin{lstlisting}
`\refcode{LoopSubdiv Function Definitions}{+=}\lastnext{LoopSubdivFunctionDefinitions}`
static `\refvar{Point3f}{}` `\initvar{weightOneRing}{}`(`\refvar{SDVertex}{}` *vert, `\refvar{Float}{}` beta) {
    `\refcode{Put vert one-ring in pRing}{}`
    `\refvar{Point3f}{}` p = (1 - valence * beta) * vert->`\refvar[SDVertex::p]{p}{}`;
    for (int i = 0; i < valence; ++i)
        p += beta * pRing[i];
    return p;
}  
\end{lstlisting}

因为一环内有不定数量的顶点，所以我们用宏\refvar{ALLOCA}{()}来
高效分配空间存储它们的位置。
\begin{lstlisting}
`\initcode{Put vert one-ring in pRing}{=}`
int valence = vert->`\refvar{valence}{}`();
`\refvar{Point3f}{}` *pRing = `\refvar{ALLOCA}{}`(`\refvar{Point3f}{}`, valence);
vert->`\refvar{oneRing}{}`(pRing);
\end{lstlisting}

方法\refvar{oneRing}{()}假设传入的指针指向一片足够大的内存区域以存储绕该顶点的一环。
\begin{lstlisting}
`\refcode{LoopSubdiv Function Definitions}{+=}\lastnext{LoopSubdivFunctionDefinitions}`
void `\refvar{SDVertex}{}`::`\initvar{oneRing}{}`(`\refvar{Point3f}{}` *p) {
    if (!`\refvar[SDVertex::boundary]{boundary}{}`) {
        `\refcode{Get one-ring vertices for interior vertex}{}`
    } else {
        `\refcode{Get one-ring vertices for boundary vertex}{}`
    }
}
\end{lstlisting}

获取绕内部顶点的一环相对简单，可以通过遍历与该顶点相邻的面并
对每个面保留中心顶点后面的那个顶点来实现
（用笔纸简单打个草稿你就能理解该过程会返回一环内的所有顶点）。
\begin{lstlisting}
`\initcode{Get one-ring vertices for interior vertex}{=}`
`\refvar{SDFace}{}` *face = `\refvar{startFace}{}`;
do {
    *p++ = face->`\refvar{nextVert}{}`(this)->`\refvar[SDVertex::p]{p}{}`;
    face = face-`\refvar{nextFace}{}`(this);
} while (face != `\refvar{startFace}{}`);
\end{lstlisting}

绕边界顶点的一环有些棘手。
这里的实现在给定的\refvar{Point3f}{}数组中仔细存储一环，
使数组中首尾元素是沿边界的相邻顶点。
该顺序很重要，因为相邻边界顶点的赋权常常不同于网格内部的相邻顶点。
这样做要求我们先遍历周围相邻面直到到达边界，
然后朝另一个方向遍历，并一个接一个地存储顶点。
\begin{lstlisting}
`\initcode{Get one-ring vertices for boundary vertex}{=}`
`\refvar{SDFace}{}` *face = `\refvar{startFace}{}`, *f2;
while ((f2 = face->`\refvar{nextFace}{}`(this)) != nullptr)
    face = f2;
*p++ = face->`\refvar{nextVert}{}`(this)->`\refvar[SDVertex::p]{p}{}`;
do {
    *p++ = face->`\refvar{prevVert}{}`(this)->`\refvar[SDVertex::p]{p}{}`;
    face = face->`\refvar{prevFace}{}`(this);
} while (face != nullptr);
\end{lstlisting}

对于边界上的顶点，新顶点的位置只基于两个邻接边界顶点（\reffig{3.34}）。
不依赖内部顶点保证了共享着边界上相同顶点的
两个邻接\sidenote{译者注：原文abutting。}曲面会有邻接的极限曲面。
实用函数\refvar{weightBoundary}{()}将给定权重赋给
两个相邻顶点$\bm v_1$和$\bm v_2$来算得新位置$\bm v'$为
\begin{align*}
    \bm v'=(1-2\beta)\bm v+\beta\bm v_1+\beta\bm v_2\, .
\end{align*}

正则和非凡顶点都用相同的权重$\displaystyle\frac{1}{8}$.
\begin{figure}[htbp]
    \centering\includegraphics[width=0.25\linewidth]{chap03/Subdivboundaryweighting.eps}
    \caption{边界边上的细分。中心顶点的新位置通过对它和它的两个相邻顶点赋予所示权重算得。}
    \label{fig:3.34}
\end{figure}

\begin{lstlisting}
`\initcode{Apply boundary rule for even vertex}{=}`
vertex->`\refvar{child}{}`->`\refvar[SDVertex::p]{p}{}` = `\refvar{weightBoundary}{}`(vertex, 1.f / 8.f);
\end{lstlisting}

实用函数\refvar{weightBoundary}{()}将给定权重赋给边界顶点。
它的实现很简单，因为函数\refvar[oneRing]{SDVertex::oneRing}{()}将
边界顶点的一环排成首尾元素是边界邻居。
\begin{lstlisting}
`\refcode{LoopSubdiv Function Definitions}{+=}\lastcode{LoopSubdivFunctionDefinitions}`
static `\refvar{Point3f}{}` `\initvar{weightBoundary}{}`(`\refvar{SDVertex}{}` *vert, `\refvar{Float}{}` beta) {
    `\refcode{Put vert one-ring in pRing}{}`
    `\refvar{Point3f}{}` p = (1 - 2 * beta) * vert->`\refvar[SDVertex::p]{p}{}`;
    p += beta * pRing[0];
    p += beta * pRing[valence - 1];
    return p;
}
\end{lstlisting}

现在细化方法计算奇顶点的位置——沿网格分割边的新顶点。
它遍历网格中每个面的每条边，计算划分边的新顶点（\reffig{3.35}）。
对于内部边，通过赋权边两端的顶点以及
该边相邻面的相对顶点可以求得新顶点。
它遍历每个面的全部三条边，每次遇到之前没见过的边它就
计算对应该边的新的奇顶点并存于关联的{\ttfamily edgeVerts}数组中。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.75\linewidth]{chap03/Subdivedgesplit.eps}
    \caption{边分割的细分规则。空心圆标出的新的奇顶点的位置是通过
        赋权该边两端的顶点以及相邻三角形与之相对的两个顶点求得的。
        (a)内部顶点的权重；(b)边界顶点的权重。}
    \label{fig:3.35}
\end{figure}

\begin{lstlisting}
`\initcode{Compute new odd edge vertices}{=}`
std::map<`\refvar{SDEdge}{}`, `\refvar{SDVertex}{}` *> edgeVerts;
for (`\refvar{SDFace}{}` *face : f) {
    for (int k = 0; k < 3; ++k) {
        `\refcode{Compute odd vertex on kth edge}{}`
    }
}
\end{lstlisting}

就像设置原始网格中的相邻面指针做的那样，
为每条边创建\refvar{SDEdge}{}对象并检查它是否在已访问的边集合中。
如果没在，则计算该边上的新顶点并添入{\ttfamily map}，
它是高效执行查找的关联数组结构。
\begin{lstlisting}
`\initcode{Compute odd vertex on kth edge}{=}`
`\refvar{SDEdge}{}` edge(face->`\refvar[SDFace::v]{v}{}`[k], face->`\refvar[SDFace::v]{v}{}`[`\refvar{NEXT}{}`(k)]);
`\refvar{SDVertex}{}` *vert = edgeVerts[edge];
if (!vert) {
    `\refcode{Create and initialize new odd vertex}{}`
    `\refcode{Apply edge rules to compute new vertex position}{}`
    edgeVerts[edge] = vert;
}
\end{lstlisting}

在Loop细分中，细分加入的新顶点总是正则的
（这意味着非凡顶点相对于正则顶点的比例会随着每级细分下降）。
因此，新顶点的成员\refvar{regular}{}可以立即设为{\ttfamily true}。
成员\refvar[SDVertex::boundary]{boundary}{}也很容易通过检查正在分割的边是否有相邻面来初始化。
最后，新顶点的指针\refvar{startFace}{}也可在这里设置。
对于一个面的边上任何一个奇顶点，中心孩子（三号子面）保证与新顶点相邻。
\begin{lstlisting}
`\initcode{Create and initialize new odd vertex}{=}`
vert = arena.`\refvar[MemoryArena:Alloc2]{Alloc}{}`<`\refvar{SDVertex}{}`>();
newVertices.push_back(vert);
vert->`\refvar{regular}{}` = true;
vert->`\refvar[SDVertex::boundary]{boundary}{}` = (face->`\refvar[SDFace::f]{f}{}`[k] == nullptr);
vert->`\refvar{startFace}{}` = face->`\refvar[SDFace::children]{children}{}`[3];
\end{lstlisting}

对于边界奇顶点，新顶点只是两个相邻顶点的均值。
对于内部奇顶点，该边两端顶点被赋权$\displaystyle\frac{3}{8}$，
与该边相对的两个顶点被赋权$\displaystyle\frac{1}{8}$（\reffig{3.35}）。
后两个顶点可用实用函数\refvar[otherVert]{SDFace::otherVert}{()}找到，
返回一个面与给定边相对的顶点。
\begin{lstlisting}
`\initcode{Apply edge rules to compute new vertex position}{=}`
if (vert->`\refvar[SDVertex::boundary]{boundary}{}`) {
    vert->`\refvar[SDVertex::p]{p}{}` =  0.5f * edge.`\refvar[SDEdge::v]{v}{}`[0]->`\refvar[SDVertex::p]{p}{}`;
    vert->`\refvar[SDVertex::p]{p}{}` += 0.5f * edge.`\refvar[SDEdge::v]{v}{}`[1]->`\refvar[SDVertex::p]{p}{}`;
} else {
    vert->`\refvar[SDVertex::p]{p}{}` =  3.f/8.f * edge.`\refvar[SDEdge::v]{v}{}`[0]->`\refvar[SDVertex::p]{p}{}`;
    vert->`\refvar[SDVertex::p]{p}{}` += 3.f/8.f * edge.`\refvar[SDEdge::v]{v}{}`[1]->`\refvar[SDVertex::p]{p}{}`;
    vert->`\refvar[SDVertex::p]{p}{}` += 1.f/8.f * face->`\refvar{otherVert}{}`(edge.`\refvar[SDEdge::v]{v}{}`[0], edge.`\refvar[SDEdge::v]{v}{}`[1])->`\refvar[SDVertex::p]{p}{}`;
    vert->`\refvar[SDVertex::p]{p}{}` += 1.f/8.f *
        face->`\refvar[SDFace::f]{f}{}`[k]->`\refvar{otherVert}{}`(edge.`\refvar[SDEdge::v]{v}{}`[0], edge.`\refvar[SDEdge::v]{v}{}`[1])->`\refvar[SDVertex::p]{p}{}`;
}
\end{lstlisting}

方法\refvar[otherVert]{SDFace::otherVert}{()}不言自明
\sidenote{译者注：原文第6行代码有错词，作者已接受建议并在第四版中做了修改。
详见\url{https://github.com/mmp/pbrt-v4/issues/146}和\url{https://github.com/mmp/pbrt-v4/commit/ba2be7}。}：
\begin{lstlisting}
`\refcode{SDFace Methods}{+=}\lastcode{SDFaceMethods}`
`\refvar{SDVertex}{}` *`\initvar{otherVert}{}`(`\refvar{SDVertex}{}` *v0, `\refvar{SDVertex}{}` *v1) {
    for (int i = 0; i < 3; ++i)
        if (`\refvar[SDFace::v]{v}{}`[i] != v0 && `\refvar[SDFace::v]{v}{}`[i] != v1)
            return `\refvar[SDFace::v]{v}{}`[i];
    `\refvar{Severe}{}`("Basic logic error in SDFace::otherVert()");
    return nullptr;
}
\end{lstlisting}

\subsubsection*{更新网格拓扑}
为了让拓扑更新的细节尽可能简单，
仔细选取细分面及其顶点的编号方案（\reffig{3.36}）。
仔细看图；所示约定是后面几页的关键。
\begin{figure}[htbp]
    \centering\includegraphics[width=\linewidth]{chap03/Subdivvertfacepointerupdate.eps}
    \caption{每个面都分为四个子面，第{\ttfamily i}子面与原始面的第{\ttfamily i}顶点相邻，
    第{\ttfamily i}子面的第{\ttfamily i}顶点是原始面的第{\ttfamily i}顶点。
    中心子面的顶点朝向为第{\ttfamily i}顶点是沿父面第{\ttfamily i}边的奇顶点。}
    \label{fig:3.36}
\end{figure}

更新细化网格的拓扑指针需要四大任务：
\begin{enumerate}
    \item 奇顶点的指针\refvar[startFace]{SDVertex::startFace}{}需存储指向其相邻面之一的指针。
    \item 同样，必须设置偶顶点的指针\refvar[startFace]{SDVertex::startFace}{}。
    \item 需要设置新面的相邻指针{\ttfamily\refvar[SDFace::f]{f}{}[i]}指向相邻面。
    \item 新面的指针{\ttfamily\refvar[SDFace::v]{v}{}[i]}需要指向合适的顶点。
\end{enumerate}

奇顶点的指针\refvar{startFace}{}在首次创建时就已经初始化了。
这里我们依次处理其余三个任务。
\begin{lstlisting}
`\initcode{Update new mesh topology}{=}`
`\refcode{Update even vertex face pointers}{}`
`\refcode{Update face neighbor pointers}{}`
`\refcode{Update face vertex pointers}{}`
\end{lstlisting}

如果一个顶点是其\refvar{startFace}{}的第{\ttfamily i}顶点，
则它保证会与\refvar{startFace}{}的第{\ttfamily i}子面相邻。
因此，只需要遍历网格中所有父顶点，
对每一个求取它在其\refvar{startFace}{}中的顶点索引。
然后可用该索引找到与新的偶顶点相邻的子面。
\begin{lstlisting}
`\initcode{Update even vertex face pointers}{=}`
for (`\refvar{SDVertex}{}` *vertex : v) {
    int vertNum = vertex->`\refvar{startFace}{}`->`\refvar{vnum}{}`(vertex);
    vertex->`\refvar{child}{}`->`\refvar{startFace}{}` = 
        vertex->`\refvar{startFace}{}`->`\refvar[SDFace::children]{children}{}`[vertNum];
}
\end{lstlisting}

接着，更新新建面的相邻面指针。
我们将其分为两步：一个是更新同父的子面间的邻居，
一个是更新异父的子面间的邻居。这涉及一些棘手的指针操作。
\begin{lstlisting}
`\initcode{Update face neighbor pointers}{=}`
for (`\refvar{SDFace}{}` *face : f) {
    for (int j = 0; j < 3; ++j) {
        `\refcode{Update children f pointers for siblings}{}`
        `\refcode{Update children f pointers for neighbor children}{}`
    }
}
\end{lstlisting}

对于第一步，回想内部子面总是存于{\ttfamily\refvar[SDFace::children]{children}{}[3]}。
而且（对于{\ttfamily k}=0,1,2）第{\ttfamily k+1}子面相邻于内部面的第{\ttfamily k}边，
内部面相邻于第{\ttfamily k}面的第{\ttfamily k+1}边。
\begin{lstlisting}
`\initcode{Update children f pointers for siblings}{=}`
face->`\refvar[SDFace::children]{children}{}`[3]->`\refvar[SDFace::f]{f}{}`[j] = face->`\refvar[SDFace::children]{children}{}`[`\refvar{NEXT}{}`(j)];
face->`\refvar[SDFace::children]{children}{}`[j]->`\refvar[SDFace::f]{f}{}`[`\refvar{NEXT}{}`(j)] = face->`\refvar[SDFace::children]{children}{}`[3];
\end{lstlisting}

我们现在更新子面的指向其他父亲之子的相邻指针。
这里只有前三个子面需要处理；内部子面的相邻指针已经完全初始化了。
观察\reffig{3.36}可知第{\ttfamily k}个子面
\sidenote{译者注：原文写为第{\ttfamily i}个子面，我认为是笔误，此处已修正。}需要设置
第{\ttfamily k}和{\ttfamily\refvar{PREV}{}(k)}边。
为了设置第{\ttfamily k}子面的第{\ttfamily k}边，
我们先求父面的第{\ttfamily k}边，
则相邻父面{\ttfamily f2}与那条边相邻。
若{\ttfamily f2}存在（意味着我们不在边界上），
则求得顶点{\ttfamily v[k]}的相邻父索引。
该索引等于我们正在搜索的相邻子面的索引。
然后重复该过程寻找与第{\ttfamily\refvar{PREV}{}(k)}边相邻的子面。
\begin{lstlisting}
`\initcode{Update children f pointers for neighbor children}{=}`
`\refvar{SDFace}{}` *f2 = face->`\refvar[SDFace::f]{f}{}`[j];
face->`\refvar[SDFace::children]{children}{}`[j]->`\refvar[SDFace::f]{f}{}`[j] =
    f2 ? f2->`\refvar[SDFace::children]{children}{}`[f2->`\refvar{vnum}{}`(face->`\refvar[SDFace::v]{v}{}`[j])] : nullptr;
f2 = face->`\refvar[SDFace::f]{f}{}`[`\refvar{PREV}{}`(j)];
face->`\refvar[SDFace::children]{children}{}`[j]->`\refvar[SDFace::f]{f}{}`[`\refvar{PREV}{}`(j)] = 
    f2 ? f2->`\refvar[SDFace::children]{children}{}`[f2->`\refvar{vnum}{}`(face->`\refvar[SDFace::v]{v}{}`[j])] : nullptr;
\end{lstlisting}

最后，我们处理拓扑更新的第四步：设置子面的顶点指针。
\begin{lstlisting}
`\initcode{Update face vertex pointers}{=}`
for (`\refvar{SDFace}{}` *face : f) {
    for (int j = 0; j < 3; ++j) {
        `\refcode{Update child vertex pointer to new even vertex}{}`
        `\refcode{Update child vertex pointer to new odd vertex}{}`
    }
}
\end{lstlisting}

对于（{\ttfamily k}=0,1,2）第{\ttfamily k}子面，
第{\ttfamily k}顶点对应于与该子面相邻的偶顶点。
对于非内部子面，有一个偶顶点和两个奇顶点；对于内部子面，有三个奇顶点。
通过跟随从父面获取的父顶点的子指针可以找到该顶点。
\begin{lstlisting}
`\initcode{Update child vertex pointer to new even vertex}{=}`
face->`\refvar[SDFace::children]{children}{}`[j]->`\refvar[SDFace::v]{v}{}`[j] = face->`\refvar[SDFace::v]{v}{}`[j]->`\refvar{child}{}`;
\end{lstlisting}

为了更新剩余顶点指针，再次用关联数组{\ttfamily edgeVerts}为父面的每条分割边寻找奇顶点。
三个子面以该顶点为关联\sidenote{译者注：原文incident。}顶点。
再次基于\reffig{3.36}中建立的编号方案，很容易求得该顶点在这三个面中的索引。
\begin{lstlisting}
`\initcode{Update child vertex pointer to new odd vertex}{=}`
`\refvar{SDVertex}{}` *vert = edgeVerts[`\refvar{SDEdge}{}`(face->`\refvar[SDFace::v]{v}{}`[j], face->`\refvar[SDFace::v]{v}{}`[`\refvar{NEXT}{}`(j)])];
face->`\refvar[SDFace::children]{children}{}`[j]->`\refvar[SDFace::v]{v}{}`[`\refvar{NEXT}{}`(j)] = vert;
face->`\refvar[SDFace::children]{children}{}`[`\refvar{NEXT}{}`(j)]->`\refvar[SDFace::v]{v}{}`[j] = vert;
face->`\refvar[SDFace::children]{children}{}`[3]->`\refvar[SDFace::v]{v}{}`[j] = vert;
\end{lstlisting}

一个细分步骤完成几何和拓扑工作后，
新建的顶点和面移入数组{\ttfamily v}和{\ttfamily f}：
\begin{lstlisting}
`\initcode{Prepare for next level of subdivision}{=}`
f = newFaces;
v = newVertices;
\end{lstlisting}

\subsubsection*{逼近极限曲面并输出}
细分曲面的显著性质之一是，如果我们永远继续细分下去，
特殊的细分规则可以给出网格顶点将有的位置。
这里我们用这些规则初始化极限曲面位置的数组{\ttfamily pLimit}。
注意计算中在顶点之外的地方临时存储极限曲面的位置很重要。
因为每个顶点的极限曲面位置依赖于其周围顶点的原始位置，
所有顶点的原始位置必须保持不变直到完成计算。

边界顶点的极限规则对两个相邻顶点赋权$\displaystyle\frac{1}{5}$，
中心顶点赋权$\displaystyle\frac{3}{5}$.
内部顶点的规则基于函数\refvar{loopGamma}{()}，
它基于顶点的价计算合适的顶点权重。
\begin{lstlisting}
`\initcode{Push vertices to limit surface}{=}`
std::unique_ptr<`\refvar{Point3f}{}`[]> pLimit(new `\refvar{Point3f}{}`[v.size()]);
for (size_t i = 0; i < v.size(); ++i) {
    if (v[i]->`\refvar[SDVertex::boundary]{boundary}{}`)
        pLimit[i] =  `\refvar{weightBoundary}{}`(v[i], 1.f / 5.f);
    else
        pLimit[i] =  `\refvar{weightOneRing}{}`(v[i], `\refvar{loopGamma}{}`(v[i]->`\refvar{valence}{}`()));
}
for (size_t i = 0; i < v.size(); ++i)
    v[i]->`\refvar[SDVertex::p]{p}{}` = pLimit[i];
\end{lstlisting}
\begin{lstlisting}
`\refcode{LoopSubdiv Inline Functions}{+=}\lastcode{LoopSubdivInlineFunctions}`
inline `\refvar{Float}{}` `\initvar{loopGamma}{}`(int valence) {
    return 1.f / (valence + 3.f / (8.f * `\refvar{beta}{}`(valence)));
}
\end{lstlisting}

为了生成看起来光滑的、带有每个顶点曲面法线的三角网格，
每个顶点处都计算极限曲面一对不平行的切向量。
与位置的极限规则一样，这是给出实际极限曲面上精确切线的解析计算。
\begin{lstlisting}
`\initcode{Compute vertex tangents on limit surface}{=}`
std::vector<`\refvar{Normal3f}{}`> Ns;
Ns.reserve(v.size());
std::vector<`\refvar{Point3f}{}`> pRing(16, `\refvar{Point3f}{}`());
for (`\refvar{SDVertex}{}` *vertex : v) {
    `\refvar{Vector3f}{}` S(0,0,0), T(0,0,0);
    int valence = vertex->`\refvar{valence}{}`();
    if (valence > (int)pRing.size())
        pRing.resize(valence);
    vertex->`\refvar{oneRing}{}`(&pRing[0]);
    if (!vertex->`\refvar[SDVertex::boundary]{boundary}{}`) {
        `\refcode{Compute tangents of interior face}{}`
    } else {
        `\refcode{Compute tangents of boundary face}{}`
    }
    Ns.push_back(`\refvar{Normal3f}{}`(`\refvar{Cross}{}`(S, T)));
}
\end{lstlisting}

\reffig{3.37}展示了计算网格内部切线的设置。
中心顶点赋权为零，邻居赋权$w_i$.
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivtangents.eps}
    \caption{计算内部顶点的切线，一环顶点赋权为$w_i$.计算切线的中心顶点总是赋权为零。}
    \label{fig:3.37}
\end{figure}

为了计算首个切向量$\bm s$，权重为
\begin{align*}
    w_i=\cos{\left(\frac{2\pi i}{n}\right)}\, ,
\end{align*}
其中$n$为该顶点的价。计算第二个切向量$\bm t$用的权重为
\begin{align*}
    w_i=\sin{\left(\frac{2\pi i}{n}\right)}\, .
\end{align*}

\begin{lstlisting}
`\initcode{Compute tangents of interior face}{=}`
for (int j = 0; j < valence; ++j) {
    S += std::cos(2 * `\refvar{Pi}{}` * j / valence) * `\refvar{Vector3f}{}`(pRing[j]);
    T += std::sin(2 * `\refvar{Pi}{}` * j / valence) * `\refvar{Vector3f}{}`(pRing[j]);
}
\end{lstlisting}

边界顶点的切线有些棘手。\reffig{3.38}展示了后续讨论要求的一环顶点顺序
\sidenote{译者注：原图没有正确显示下标，已修正。}。
\begin{figure}[htbp]
    \centering\includegraphics[width=0.35\linewidth]{chap03/Subdivedgetangents.eps}
    \caption{边界顶点的切线也计算为相邻顶点的加权平均。
        然而，一些边界切线规则并入了中心顶点的值。}
    \label{fig:3.38}
\end{figure}

第一条切线叫\keyindex{跨越切线}{across tangent}{tangent line\ 切线}，
由两相邻边界顶点间的向量给出：
\begin{align*}
    \bm s=\bm v_{n-1}-\bm v_0\, .
\end{align*}

第二条切线叫\keyindex{横断切线}{transverse tangent}{tangent line\ 切线}，
基于顶点的价算得。
中心顶点赋权$w_{\mathrm{c}}$，一环顶点赋权指定为向量$(w_0,w_1,\ldots,w_{n-1})$.
我们的横断切线规则是
\begin{table}[h]
    \centering\begin{tabular}{lll}
        \toprule
        价        & $w_{\mathrm{c}}$ & $w_i$       \\
        \midrule
        2         & -2               & (1,1)       \\
        3         & -1               & (0,1,0)     \\
        4（正则） & -2               & (-1,2,2,-1) \\
        \bottomrule
    \end{tabular}
\end{table}

价为5及以上时，$w_{\mathrm{c}}=0$且
\begin{align*}
    w_0 & =w_{n-1}=\sin{\theta}\, ,              \\
    w_i & =(2\cos{\theta}-2)\sin{(\theta i)}\, ,
\end{align*}
其中
\begin{align*}
    \theta=\frac{\pi}{n-1}\, .
\end{align*}

尽管这里我们没有证明，但对于所有$i$值这些权重都有和为零。
这保证了加权和实际上是切向量。
\begin{lstlisting}
`\initcode{Compute tangents of boundary face}{=}`
S = pRing[valence - 1] - pRing[0];
if (valence == 2)
    T = `\refvar{Vector3f}{}`(pRing[0] + pRing[1] - 2 * vertex->`\refvar[SDVertex::p]{p}{}`);
else if (valence == 3)
    T = pRing[1] - vertex->`\refvar[SDVertex::p]{p}{}`;
else if (valence == 4) // regular
    T = `\refvar{Vector3f}{}`(-1 * pRing[0] +  2 * pRing[1] + 2 * pRing[2] + 
                 -1 * pRing[3] + -2 * vertex->`\refvar[SDVertex::p]{p}{}`);
else {
    `\refvar{Float}{}` theta = `\refvar{Pi}{}` / float(valence - 1);
    T = `\refvar{Vector3f}{}`(std::sin(theta) * (pRing[0] + pRing[valence - 1]));
    for (int k = 1; k < valence - 1; ++k) {
        `\refvar{Float}{}` wt = (2 * std::cos(theta) - 2) * std::sin((k) * theta);
        T += `\refvar{Vector3f}{}`(wt * pRing[k]);
    }
    T = -T;
}
\end{lstlisting}

最后，代码片\refcode{Create triangle mesh from subdivision mesh}{}初始化
对应于极限曲面三角化的\refvar{Triangle}{}向量。
它即简单将细分网格转为索引化的三角网格。
\begin{lstlisting}
`\initcode{Create triangle mesh from subdivision mesh}{=}`
{
    size_t ntris = f.size();
    std::unique_ptr<int[]> verts(new int[3*ntris]);
    int *vp = verts.get();
    size_t totVerts = v.size();
    std::map<`\refvar{SDVertex}{}` *, int> usedVerts;
    for (size_t i = 0; i < totVerts; ++i)
        usedVerts[v[i]] = i;
    for (size_t i = 0; i < ntris; ++i) {
        for (int j = 0; j < 3; ++j) {
            *vp = usedVerts[f[i]->`\refvar[SDFace::v]{v}{}`[j]];
            ++vp;
        }
    }
    return `\refvar{CreateTriangleMesh}{}`(ObjectToWorld, WorldToObject, reverseOrientation, ntris, verts.get(),
        totVerts, pLimit.get(), nullptr, &Ns[0], nullptr, nullptr);
}
\end{lstlisting}